/*
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.ui.contentassist

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.CrossReference
import com.google.inject.Inject
import de.ubt.ai1.m2m.bxtenddsl.scoping.BXtendDSLScopeProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.nodemodel.impl.RootNode
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.jface.viewers.StyledString
import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry
import org.eclipse.emf.edit.EMFEditPlugin
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.EcoreUtil2
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule
import org.eclipse.xtext.Keyword
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.emf.ecore.EcorePackage
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.MappingFeature
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class BXtendDSLProposalProvider extends AbstractBXtendDSLProposalProvider {
	override void completeSrcClassMatcher_Clazz(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		lookupCrossReference(scopeProvider.srcMetamodelScope(model), assignment, context, acceptor)
	}
	override void completeTrgClassMatcher_Clazz(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		lookupCrossReference(scopeProvider.trgMetamodelScope(model), assignment, context, acceptor)
	}
	
	override void completeSrcMappingFeature_Feature(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rule = EcoreUtil2.getContainerOfType(model, TransformationRule) ?: (model as BXtendDSL).rules.last()
		val scope = scopeProvider.srcMatcherScope(rule)
		val filteredScope = if (model instanceof MappingFeature && (model as MappingFeature).corr) {
			new FilteringScope(scope, [EcorePackage.eINSTANCE.EReference.isSuperTypeOf(it.EClass)])
		} else {
			scope
		}
		lookupCrossReference(filteredScope, assignment, context, acceptor)
	}
	override void completeTrgMappingFeature_Feature(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rule = EcoreUtil2.getContainerOfType(model, TransformationRule) ?: (model as BXtendDSL).rules.last()
		val scope = scopeProvider.trgMatcherScope(rule)
		val filteredScope = if (model instanceof MappingFeature && (model as MappingFeature).corr) {
			new FilteringScope(scope, [EcorePackage.eINSTANCE.EReference.isSuperTypeOf(it.EClass)])
		} else {
			scope
		}
		lookupCrossReference(filteredScope, assignment, context, acceptor)
	}
	
	override void completeFeatureMapping_SrcClasses(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rule = EcoreUtil2.getContainerOfType(model, TransformationRule) ?: (model as BXtendDSL).rules.last()
		val forbiddenClassMatcher = rule.srcMatcher.filter[modifier === null || !modifier.group].map[name].toList()
		lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor,
				[!forbiddenClassMatcher.contains(it.name.toString())])
	}
	override void completeFeatureMapping_TrgClasses(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rule = EcoreUtil2.getContainerOfType(model, TransformationRule) ?: (model as BXtendDSL).rules.last()
		val forbiddenClassMatcher = rule.trgMatcher.filter[modifier === null || !modifier.group].map[name].toList()
		lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor,
				[!forbiddenClassMatcher.contains(it.name.toString())])
	}
	
	override void complete_TAB_INDENTED_BLOCK_BEGIN(EObject model, RuleCall ruleCall,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val beforeOffset = (context.rootNode as RootNode).completeContent.substring(0, context.offset)
		val lastLineBreak = beforeOffset.lastIndexOf(System.lineSeparator())
		val lineBreakTabsRegex = System.lineSeparator().replaceAll("\\\\", "\\\\\\\\") + "\t*"
		
		var ICompletionProposal completionProposal = null
		if (beforeOffset.substring(lastLineBreak).matches(lineBreakTabsRegex)) {
			completionProposal = createCompletionProposal("\t", "block begin", genericImage(), context)
		} else {
			val indentation = beforeOffset.substring(lastLineBreak).toCharArray().filter[it == "\t".charAt(0)].join()
			val proposal = System.lineSeparator() + indentation + "\t"
			completionProposal = createCompletionProposal(proposal, "block begin", genericImage(), context)
		}
		// default priority is 400
		if (completionProposal instanceof ConfigurableCompletionProposal) completionProposal.priority = 42
		acceptor.accept(completionProposal)
	}
	override void complete_TAB_INDENTED_BLOCK_END(EObject model, RuleCall ruleCall,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val beforeOffset = (context.rootNode as RootNode).completeContent.substring(0, context.offset)
		val lastLineBreak = beforeOffset.lastIndexOf(System.lineSeparator())
		val lineBreakTabsRegex = System.lineSeparator().replaceAll("\\\\", "\\\\\\\\") + "\t*"
		
		var ICompletionProposal completionProposal = null
		if (beforeOffset.substring(lastLineBreak).matches(lineBreakTabsRegex)) {
			completionProposal = new ConfigurableCompletionProposal("", context.offset - 1, 1, 0,
					genericImage(), new StyledString("block end"), null, null)
			(completionProposal as ConfigurableCompletionProposal).setMatcher(context.getMatcher())
			val replacementContextLength = getReplacementContextLength(context)
			(completionProposal as ConfigurableCompletionProposal).setReplaceContextLength(replacementContextLength)
		} else {
			val indentation = beforeOffset.substring(lastLineBreak).toCharArray().filter[it == "\t".charAt(0)].join()
			val proposal = System.lineSeparator() + indentation.substring(0, Math.max(0, indentation.length() - 1))
			completionProposal = createCompletionProposal(proposal, "block end", genericImage(), context)
		}
		if (completionProposal instanceof ConfigurableCompletionProposal) completionProposal.priority = 42
		acceptor.accept(completionProposal)
	}
	
	override void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
			ICompletionProposalAcceptor acceptor) {
		if (keyword.value == "{") {
			// default keyword priority is 300
			val completionProposal = createCompletionProposal(keyword.value, new StyledString("{ - corr feature"),
					getImage(keyword), 301, contentAssistContext.prefix, contentAssistContext)
			acceptor.accept(completionProposal)
		} else {
			super.completeKeyword(keyword, contentAssistContext, acceptor)
		}
	}
	
	@Inject BXtendDSLScopeProvider scopeProvider
	
	def private void lookupCrossReference(IScope scope, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val crossReference = assignment.getTerminal() as CrossReference
		val ruleName = if (crossReference.getTerminal() instanceof RuleCall) {
				(crossReference.getTerminal() as RuleCall).getRule().getName()
			} else {
				null
			}
		val proposalFactory = getProposalFactory(ruleName, context)
		
		for (candidate : scope.allElements) {
			if (!acceptor.canAcceptMoreProposals()) {
				return
			}
			
			val proposal = proposalFactory.apply(candidate)
			// so custom looked up cross refs are positioned slightly under default looked up cross refs
			if (proposal instanceof ConfigurableCompletionProposal) proposal.priority = proposal.priority - 42
			acceptor.accept(proposal)
		}
	}
	
	def private Image genericImage() {
		// alternative images: "full/obj16/TextValue", "full/obj16/BooleanValue", "full/obj16/RealValue"
		val imageString = "full/obj16/GenericValue"
		val imageDescription = EMFEditPlugin.INSTANCE.getImage(imageString)
		return ExtendedImageRegistry.INSTANCE.getImage(imageDescription)
	}
}
