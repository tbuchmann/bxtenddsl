/**
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.ui.contentassist;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.inject.Inject;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.MappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.scoping.BXtendDSLScopeProvider;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.edit.EMFEditPlugin;
import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.AbstractElement;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.impl.RootNode;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
@SuppressWarnings("all")
public class BXtendDSLProposalProvider extends AbstractBXtendDSLProposalProvider {
  @Override
  public void completeSrcClassMatcher_Clazz(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.lookupCrossReference(this.scopeProvider.srcMetamodelScope(model), assignment, context, acceptor);
  }
  
  @Override
  public void completeTrgClassMatcher_Clazz(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.lookupCrossReference(this.scopeProvider.trgMetamodelScope(model), assignment, context, acceptor);
  }
  
  @Override
  public void completeSrcMappingFeature_Feature(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    TransformationRule _elvis = null;
    TransformationRule _containerOfType = EcoreUtil2.<TransformationRule>getContainerOfType(model, TransformationRule.class);
    if (_containerOfType != null) {
      _elvis = _containerOfType;
    } else {
      TransformationRule _last = IterableExtensions.<TransformationRule>last(((BXtendDSL) model).getRules());
      _elvis = _last;
    }
    final TransformationRule rule = _elvis;
    final IScope scope = this.scopeProvider.srcMatcherScope(rule);
    IScope _xifexpression = null;
    if (((model instanceof MappingFeature) && ((MappingFeature) model).isCorr())) {
      final Predicate<IEObjectDescription> _function = (IEObjectDescription it) -> {
        return EcorePackage.eINSTANCE.getEReference().isSuperTypeOf(it.getEClass());
      };
      _xifexpression = new FilteringScope(scope, _function);
    } else {
      _xifexpression = scope;
    }
    final IScope filteredScope = _xifexpression;
    this.lookupCrossReference(filteredScope, assignment, context, acceptor);
  }
  
  @Override
  public void completeTrgMappingFeature_Feature(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    TransformationRule _elvis = null;
    TransformationRule _containerOfType = EcoreUtil2.<TransformationRule>getContainerOfType(model, TransformationRule.class);
    if (_containerOfType != null) {
      _elvis = _containerOfType;
    } else {
      TransformationRule _last = IterableExtensions.<TransformationRule>last(((BXtendDSL) model).getRules());
      _elvis = _last;
    }
    final TransformationRule rule = _elvis;
    final IScope scope = this.scopeProvider.trgMatcherScope(rule);
    IScope _xifexpression = null;
    if (((model instanceof MappingFeature) && ((MappingFeature) model).isCorr())) {
      final Predicate<IEObjectDescription> _function = (IEObjectDescription it) -> {
        return EcorePackage.eINSTANCE.getEReference().isSuperTypeOf(it.getEClass());
      };
      _xifexpression = new FilteringScope(scope, _function);
    } else {
      _xifexpression = scope;
    }
    final IScope filteredScope = _xifexpression;
    this.lookupCrossReference(filteredScope, assignment, context, acceptor);
  }
  
  @Override
  public void completeFeatureMapping_SrcClasses(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    TransformationRule _elvis = null;
    TransformationRule _containerOfType = EcoreUtil2.<TransformationRule>getContainerOfType(model, TransformationRule.class);
    if (_containerOfType != null) {
      _elvis = _containerOfType;
    } else {
      TransformationRule _last = IterableExtensions.<TransformationRule>last(((BXtendDSL) model).getRules());
      _elvis = _last;
    }
    final TransformationRule rule = _elvis;
    final Function1<SrcClassMatcher, Boolean> _function = (SrcClassMatcher it) -> {
      return Boolean.valueOf(((it.getModifier() == null) || (!it.getModifier().isGroup())));
    };
    final Function1<SrcClassMatcher, String> _function_1 = (SrcClassMatcher it) -> {
      return it.getName();
    };
    final List<String> forbiddenClassMatcher = IterableExtensions.<String>toList(IterableExtensions.<SrcClassMatcher, String>map(IterableExtensions.<SrcClassMatcher>filter(rule.getSrcMatcher(), _function), _function_1));
    AbstractElement _terminal = assignment.getTerminal();
    final Predicate<IEObjectDescription> _function_2 = (IEObjectDescription it) -> {
      boolean _contains = forbiddenClassMatcher.contains(it.getName().toString());
      return (!_contains);
    };
    this.lookupCrossReference(((CrossReference) _terminal), context, acceptor, _function_2);
  }
  
  @Override
  public void completeFeatureMapping_TrgClasses(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    TransformationRule _elvis = null;
    TransformationRule _containerOfType = EcoreUtil2.<TransformationRule>getContainerOfType(model, TransformationRule.class);
    if (_containerOfType != null) {
      _elvis = _containerOfType;
    } else {
      TransformationRule _last = IterableExtensions.<TransformationRule>last(((BXtendDSL) model).getRules());
      _elvis = _last;
    }
    final TransformationRule rule = _elvis;
    final Function1<TrgClassMatcher, Boolean> _function = (TrgClassMatcher it) -> {
      return Boolean.valueOf(((it.getModifier() == null) || (!it.getModifier().isGroup())));
    };
    final Function1<TrgClassMatcher, String> _function_1 = (TrgClassMatcher it) -> {
      return it.getName();
    };
    final List<String> forbiddenClassMatcher = IterableExtensions.<String>toList(IterableExtensions.<TrgClassMatcher, String>map(IterableExtensions.<TrgClassMatcher>filter(rule.getTrgMatcher(), _function), _function_1));
    AbstractElement _terminal = assignment.getTerminal();
    final Predicate<IEObjectDescription> _function_2 = (IEObjectDescription it) -> {
      boolean _contains = forbiddenClassMatcher.contains(it.getName().toString());
      return (!_contains);
    };
    this.lookupCrossReference(((CrossReference) _terminal), context, acceptor, _function_2);
  }
  
  @Override
  public void complete_TAB_INDENTED_BLOCK_BEGIN(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    ICompositeNode _rootNode = context.getRootNode();
    final String beforeOffset = ((RootNode) _rootNode).getCompleteContent().substring(0, context.getOffset());
    final int lastLineBreak = beforeOffset.lastIndexOf(System.lineSeparator());
    String _replaceAll = System.lineSeparator().replaceAll("\\\\", "\\\\\\\\");
    final String lineBreakTabsRegex = (_replaceAll + "\t*");
    ICompletionProposal completionProposal = null;
    boolean _matches = beforeOffset.substring(lastLineBreak).matches(lineBreakTabsRegex);
    if (_matches) {
      completionProposal = this.createCompletionProposal("\t", "block begin", this.genericImage(), context);
    } else {
      final Function1<Character, Boolean> _function = (Character it) -> {
        char _charAt = "\t".charAt(0);
        return Boolean.valueOf(((it).charValue() == _charAt));
      };
      final String indentation = IterableExtensions.join(IterableExtensions.<Character>filter(((Iterable<Character>)Conversions.doWrapArray(beforeOffset.substring(lastLineBreak).toCharArray())), _function));
      String _lineSeparator = System.lineSeparator();
      String _plus = (_lineSeparator + indentation);
      final String proposal = (_plus + "\t");
      completionProposal = this.createCompletionProposal(proposal, "block begin", this.genericImage(), context);
    }
    if ((completionProposal instanceof ConfigurableCompletionProposal)) {
      ((ConfigurableCompletionProposal)completionProposal).setPriority(42);
    }
    acceptor.accept(completionProposal);
  }
  
  @Override
  public void complete_TAB_INDENTED_BLOCK_END(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    ICompositeNode _rootNode = context.getRootNode();
    final String beforeOffset = ((RootNode) _rootNode).getCompleteContent().substring(0, context.getOffset());
    final int lastLineBreak = beforeOffset.lastIndexOf(System.lineSeparator());
    String _replaceAll = System.lineSeparator().replaceAll("\\\\", "\\\\\\\\");
    final String lineBreakTabsRegex = (_replaceAll + "\t*");
    ICompletionProposal completionProposal = null;
    boolean _matches = beforeOffset.substring(lastLineBreak).matches(lineBreakTabsRegex);
    if (_matches) {
      int _offset = context.getOffset();
      int _minus = (_offset - 1);
      Image _genericImage = this.genericImage();
      StyledString _styledString = new StyledString("block end");
      ConfigurableCompletionProposal _configurableCompletionProposal = new ConfigurableCompletionProposal("", _minus, 1, 0, _genericImage, _styledString, null, null);
      completionProposal = _configurableCompletionProposal;
      ((ConfigurableCompletionProposal) completionProposal).setMatcher(context.getMatcher());
      final int replacementContextLength = this.getReplacementContextLength(context);
      ((ConfigurableCompletionProposal) completionProposal).setReplaceContextLength(replacementContextLength);
    } else {
      final Function1<Character, Boolean> _function = (Character it) -> {
        char _charAt = "\t".charAt(0);
        return Boolean.valueOf(((it).charValue() == _charAt));
      };
      final String indentation = IterableExtensions.join(IterableExtensions.<Character>filter(((Iterable<Character>)Conversions.doWrapArray(beforeOffset.substring(lastLineBreak).toCharArray())), _function));
      String _lineSeparator = System.lineSeparator();
      int _length = indentation.length();
      int _minus_1 = (_length - 1);
      String _substring = indentation.substring(0, Math.max(0, _minus_1));
      final String proposal = (_lineSeparator + _substring);
      completionProposal = this.createCompletionProposal(proposal, "block end", this.genericImage(), context);
    }
    if ((completionProposal instanceof ConfigurableCompletionProposal)) {
      ((ConfigurableCompletionProposal)completionProposal).setPriority(42);
    }
    acceptor.accept(completionProposal);
  }
  
  @Override
  public void completeKeyword(final Keyword keyword, final ContentAssistContext contentAssistContext, final ICompletionProposalAcceptor acceptor) {
    String _value = keyword.getValue();
    boolean _equals = Objects.equal(_value, "{");
    if (_equals) {
      String _value_1 = keyword.getValue();
      StyledString _styledString = new StyledString("{ - corr feature");
      final ICompletionProposal completionProposal = this.createCompletionProposal(_value_1, _styledString, 
        this.getImage(keyword), 301, contentAssistContext.getPrefix(), contentAssistContext);
      acceptor.accept(completionProposal);
    } else {
      super.completeKeyword(keyword, contentAssistContext, acceptor);
    }
  }
  
  @Inject
  private BXtendDSLScopeProvider scopeProvider;
  
  private void lookupCrossReference(final IScope scope, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    AbstractElement _terminal = assignment.getTerminal();
    final CrossReference crossReference = ((CrossReference) _terminal);
    String _xifexpression = null;
    AbstractElement _terminal_1 = crossReference.getTerminal();
    if ((_terminal_1 instanceof RuleCall)) {
      AbstractElement _terminal_2 = crossReference.getTerminal();
      _xifexpression = ((RuleCall) _terminal_2).getRule().getName();
    } else {
      _xifexpression = null;
    }
    final String ruleName = _xifexpression;
    final Function<IEObjectDescription, ICompletionProposal> proposalFactory = this.getProposalFactory(ruleName, context);
    Iterable<IEObjectDescription> _allElements = scope.getAllElements();
    for (final IEObjectDescription candidate : _allElements) {
      {
        boolean _canAcceptMoreProposals = acceptor.canAcceptMoreProposals();
        boolean _not = (!_canAcceptMoreProposals);
        if (_not) {
          return;
        }
        final ICompletionProposal proposal = proposalFactory.apply(candidate);
        if ((proposal instanceof ConfigurableCompletionProposal)) {
          int _priority = ((ConfigurableCompletionProposal)proposal).getPriority();
          int _minus = (_priority - 42);
          ((ConfigurableCompletionProposal)proposal).setPriority(_minus);
        }
        acceptor.accept(proposal);
      }
    }
  }
  
  private Image genericImage() {
    final String imageString = "full/obj16/GenericValue";
    final Object imageDescription = EMFEditPlugin.INSTANCE.getImage(imageString);
    return ExtendedImageRegistry.INSTANCE.getImage(imageDescription);
  }
}
