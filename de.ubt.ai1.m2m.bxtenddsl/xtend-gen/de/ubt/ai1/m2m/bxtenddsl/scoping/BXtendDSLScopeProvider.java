/**
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.inject.Inject;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSLPackage;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.ClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Correspondence;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Metamodels;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcMappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgMappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.utils.MetamodelLoader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.naming.SimpleNameProvider;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class BXtendDSLScopeProvider extends AbstractBXtendDSLScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    FilteringScope _xblockexpression = null;
    {
      IScope _switchResult = null;
      boolean _matched = false;
      if (context instanceof SrcClassMatcher) {
        EReference _classMatcher_Clazz = BXtendDSLPackage.eINSTANCE.getClassMatcher_Clazz();
        boolean _equals = Objects.equal(reference, _classMatcher_Clazz);
        if (_equals) {
          _matched=true;
          _switchResult = this.srcMetamodelScope(context);
        }
      }
      if (!_matched) {
        if (context instanceof TrgClassMatcher) {
          EReference _classMatcher_Clazz = BXtendDSLPackage.eINSTANCE.getClassMatcher_Clazz();
          boolean _equals = Objects.equal(reference, _classMatcher_Clazz);
          if (_equals) {
            _matched=true;
            _switchResult = this.trgMetamodelScope(context);
          }
        }
      }
      if (!_matched) {
        if (context instanceof SrcMappingFeature) {
          EReference _mappingFeature_Feature = BXtendDSLPackage.eINSTANCE.getMappingFeature_Feature();
          boolean _equals = Objects.equal(reference, _mappingFeature_Feature);
          if (_equals) {
            _matched=true;
            EObject _eContainer = ((SrcMappingFeature)context).eContainer().eContainer();
            _switchResult = this.srcMatcherScope(((TransformationRule) _eContainer));
          }
        }
      }
      if (!_matched) {
        if (context instanceof TrgMappingFeature) {
          EReference _mappingFeature_Feature = BXtendDSLPackage.eINSTANCE.getMappingFeature_Feature();
          boolean _equals = Objects.equal(reference, _mappingFeature_Feature);
          if (_equals) {
            _matched=true;
            EObject _eContainer = ((TrgMappingFeature)context).eContainer().eContainer();
            _switchResult = this.trgMatcherScope(((TransformationRule) _eContainer));
          }
        }
      }
      if (!_matched) {
        if (context instanceof Correspondence) {
          EReference _correspondence_Matchers = BXtendDSLPackage.eINSTANCE.getCorrespondence_Matchers();
          boolean _equals = Objects.equal(reference, _correspondence_Matchers);
          if (_equals) {
            _matched=true;
            IScope _xifexpression = null;
            if (((((Correspondence)context).eContainer() instanceof SrcMappingFeature) && (((Correspondence)context).getRule() != null))) {
              _xifexpression = Scopes.scopeFor(((Correspondence)context).getRule().getTrgMatcher());
            } else {
              IScope _xifexpression_1 = null;
              if (((((Correspondence)context).eContainer() instanceof TrgMappingFeature) && (((Correspondence)context).getRule() != null))) {
                _xifexpression_1 = Scopes.scopeFor(((Correspondence)context).getRule().getSrcMatcher());
              } else {
                _xifexpression_1 = IScope.NULLSCOPE;
              }
              _xifexpression = _xifexpression_1;
            }
            _switchResult = _xifexpression;
          }
        }
      }
      if (!_matched) {
        return super.getScope(context, reference);
      }
      IScope scope = _switchResult;
      final Predicate<IEObjectDescription> _function = (IEObjectDescription it) -> {
        return reference.getEReferenceType().isSuperTypeOf(it.getEClass());
      };
      _xblockexpression = new FilteringScope(scope, _function);
    }
    return _xblockexpression;
  }
  
  /**
   * Returns a scope containing all objects specified in the source/target metamodel. The objects are identified
   * by their packageless name. Returns the NULLSCOPE, if there is no valid source/target metamodel.
   */
  public IScope srcMetamodelScope(final EObject context) {
    IScope _xblockexpression = null;
    {
      EObject _rootContainer = EcoreUtil.getRootContainer(context);
      Metamodels _metamodels = null;
      if (((BXtendDSL) _rootContainer)!=null) {
        _metamodels=((BXtendDSL) _rootContainer).getMetamodels();
      }
      String _sourcemodel = null;
      if (_metamodels!=null) {
        _sourcemodel=_metamodels.getSourcemodel();
      }
      final String sourcemodel = _sourcemodel;
      IScope _xifexpression = null;
      boolean _equals = Objects.equal(this.sourcemodel, sourcemodel);
      if (_equals) {
        _xifexpression = this.srcScope;
      } else {
        IScope _xblockexpression_1 = null;
        {
          this.sourcemodel = sourcemodel;
          IScope _xtrycatchfinallyexpression = null;
          try {
            _xtrycatchfinallyexpression = this.scopeFor(MetamodelLoader.load(sourcemodel, context.eResource().getResourceSet()));
          } catch (final Throwable _t) {
            if (_t instanceof Exception) {
              _xtrycatchfinallyexpression = IScope.NULLSCOPE;
            } else {
              throw Exceptions.sneakyThrow(_t);
            }
          }
          _xblockexpression_1 = this.srcScope = _xtrycatchfinallyexpression;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public IScope trgMetamodelScope(final EObject context) {
    IScope _xblockexpression = null;
    {
      EObject _rootContainer = EcoreUtil.getRootContainer(context);
      Metamodels _metamodels = null;
      if (((BXtendDSL) _rootContainer)!=null) {
        _metamodels=((BXtendDSL) _rootContainer).getMetamodels();
      }
      String _targetmodel = null;
      if (_metamodels!=null) {
        _targetmodel=_metamodels.getTargetmodel();
      }
      final String targetmodel = _targetmodel;
      IScope _xifexpression = null;
      boolean _equals = Objects.equal(this.targetmodel, targetmodel);
      if (_equals) {
        _xifexpression = this.trgScope;
      } else {
        IScope _xblockexpression_1 = null;
        {
          this.targetmodel = targetmodel;
          IScope _xtrycatchfinallyexpression = null;
          try {
            _xtrycatchfinallyexpression = this.scopeFor(MetamodelLoader.load(targetmodel, context.eResource().getResourceSet()));
          } catch (final Throwable _t) {
            if (_t instanceof Exception) {
              _xtrycatchfinallyexpression = IScope.NULLSCOPE;
            } else {
              throw Exceptions.sneakyThrow(_t);
            }
          }
          _xblockexpression_1 = this.trgScope = _xtrycatchfinallyexpression;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Returns the scope containing all elements matched by the source/target matcher of the given rule.
   */
  public IScope srcMatcherScope(final TransformationRule rule) {
    List<ClassMatcher> _elvis = null;
    EList<SrcClassMatcher> _srcMatcher = rule.getSrcMatcher();
    List<ClassMatcher> _map = null;
    if (_srcMatcher!=null) {
      final Function1<SrcClassMatcher, ClassMatcher> _function = (SrcClassMatcher it) -> {
        return ((ClassMatcher) it);
      };
      _map=ListExtensions.<SrcClassMatcher, ClassMatcher>map(_srcMatcher, _function);
    }
    if (_map != null) {
      _elvis = _map;
    } else {
      _elvis = Collections.<ClassMatcher>unmodifiableList(CollectionLiterals.<ClassMatcher>newArrayList());
    }
    return this.classMatcherScope(_elvis);
  }
  
  public IScope trgMatcherScope(final TransformationRule rule) {
    List<ClassMatcher> _elvis = null;
    EList<TrgClassMatcher> _trgMatcher = rule.getTrgMatcher();
    List<ClassMatcher> _map = null;
    if (_trgMatcher!=null) {
      final Function1<TrgClassMatcher, ClassMatcher> _function = (TrgClassMatcher it) -> {
        return ((ClassMatcher) it);
      };
      _map=ListExtensions.<TrgClassMatcher, ClassMatcher>map(_trgMatcher, _function);
    }
    if (_map != null) {
      _elvis = _map;
    } else {
      _elvis = Collections.<ClassMatcher>unmodifiableList(CollectionLiterals.<ClassMatcher>newArrayList());
    }
    return this.classMatcherScope(_elvis);
  }
  
  @Inject
  private SimpleNameProvider simpleNameProvider;
  
  @Inject
  private IQualifiedNameConverter qualifiedNameConverter;
  
  private String sourcemodel;
  
  private IScope srcScope = IScope.NULLSCOPE;
  
  private String targetmodel;
  
  private IScope trgScope = IScope.NULLSCOPE;
  
  /**
   * Computes a scope for the given metamodel using packageless names as identifiers.
   */
  private IScope scopeFor(final Resource metamodel) {
    final Function<EObject, QualifiedName> _function = (EObject e) -> {
      return this.getPackagelessName(e);
    };
    return Scopes.<EObject>scopeFor(IteratorExtensions.<EObject>toSet(metamodel.getAllContents()), _function, IScope.NULLSCOPE);
  }
  
  /**
   * Builds the packagless name for a given EObject. This name consists of the objects name prefixed by the dot
   * separated names of all containing objects until the first EPackage.
   */
  private QualifiedName getPackagelessName(final EObject e) {
    EObject current = e;
    final ArrayList<QualifiedName> packegelessName = new ArrayList<QualifiedName>();
    while (((!(current instanceof EPackage)) && (current != null))) {
      {
        final QualifiedName name = this.simpleNameProvider.getFullyQualifiedName(current);
        if ((name == null)) {
          return null;
        }
        packegelessName.add(name);
        current = current.eContainer();
      }
    }
    boolean _isEmpty = packegelessName.isEmpty();
    if (_isEmpty) {
      return null;
    } else {
      return this.qualifiedNameConverter.toQualifiedName(IterableExtensions.join(ListExtensions.<QualifiedName>reverse(packegelessName), "."));
    }
  }
  
  /**
   * Computes a scope containing the structural features of all non group matchers out of the given class matchers.
   */
  private IScope classMatcherScope(final List<ClassMatcher> classMatcher) {
    SimpleScope _xblockexpression = null;
    {
      Stream<IEObjectDescription> scopedElements = Stream.<IEObjectDescription>empty();
      final Function1<ClassMatcher, Boolean> _function = (ClassMatcher e) -> {
        return Boolean.valueOf(((!e.getClazz().eIsProxy()) && (!e.getModifier().isGroup())));
      };
      Iterable<ClassMatcher> _filter = IterableExtensions.<ClassMatcher>filter(classMatcher, _function);
      for (final ClassMatcher matcher : _filter) {
        final Function<EStructuralFeature, QualifiedName> _function_1 = (EStructuralFeature e) -> {
          QualifiedName _xifexpression = null;
          if (((matcher.getName() == null) || (e.getName() == null))) {
            _xifexpression = null;
          } else {
            String _name = matcher.getName();
            String _plus = (_name + ".");
            String _name_1 = e.getName();
            String _plus_1 = (_plus + _name_1);
            _xifexpression = this.qualifiedNameConverter.toQualifiedName(_plus_1);
          }
          return _xifexpression;
        };
        scopedElements = Stream.<IEObjectDescription>concat(scopedElements, StreamSupport.<IEObjectDescription>stream(
          Scopes.<EStructuralFeature>scopedElementsFor(matcher.getClazz().getEAllStructuralFeatures(), _function_1).spliterator(), false));
      }
      List<IEObjectDescription> _collect = scopedElements.collect(Collectors.<IEObjectDescription>toList());
      _xblockexpression = new SimpleScope(IScope.NULLSCOPE, _collect);
    }
    return _xblockexpression;
  }
}
