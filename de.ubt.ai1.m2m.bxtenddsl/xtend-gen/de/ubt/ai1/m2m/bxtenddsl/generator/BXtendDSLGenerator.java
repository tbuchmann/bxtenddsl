/**
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.ClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Direction;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.FeatureMapping;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Metamodels;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.framework.FrameworkGenerator;
import de.ubt.ai1.m2m.bxtenddsl.utils.MetamodelLoader;
import de.ubt.ai1.m2m.bxtenddsl.utils.Utils;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.ICoreRunnable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend.lib.annotations.Data;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.util.RuntimeIOException;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pure;
import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BXtendDSLGenerator extends AbstractGenerator {
  @Data
  private static class CompilationArtifacts {
    private final IdentifierScope ruleScope = new IdentifierScope();
    
    private final ArrayList<String> groupKeyFunctions = new ArrayList<String>();
    
    private final Map<ClassMatcher, String> matcherToGroupsId = new HashMap<ClassMatcher, String>();
    
    private final ArrayList<String> customFilter = new ArrayList<String>();
    
    private final ArrayList<String> matchCompareFunctions = new ArrayList<String>();
    
    private final ArrayList<FeatureMappingCompiler.Method> methodFeatureMappings = new ArrayList<FeatureMappingCompiler.Method>();
    
    @Override
    @Pure
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((this.ruleScope== null) ? 0 : this.ruleScope.hashCode());
      result = prime * result + ((this.groupKeyFunctions== null) ? 0 : this.groupKeyFunctions.hashCode());
      result = prime * result + ((this.matcherToGroupsId== null) ? 0 : this.matcherToGroupsId.hashCode());
      result = prime * result + ((this.customFilter== null) ? 0 : this.customFilter.hashCode());
      result = prime * result + ((this.matchCompareFunctions== null) ? 0 : this.matchCompareFunctions.hashCode());
      return prime * result + ((this.methodFeatureMappings== null) ? 0 : this.methodFeatureMappings.hashCode());
    }
    
    @Override
    @Pure
    public boolean equals(final Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      BXtendDSLGenerator.CompilationArtifacts other = (BXtendDSLGenerator.CompilationArtifacts) obj;
      if (this.ruleScope == null) {
        if (other.ruleScope != null)
          return false;
      } else if (!this.ruleScope.equals(other.ruleScope))
        return false;
      if (this.groupKeyFunctions == null) {
        if (other.groupKeyFunctions != null)
          return false;
      } else if (!this.groupKeyFunctions.equals(other.groupKeyFunctions))
        return false;
      if (this.matcherToGroupsId == null) {
        if (other.matcherToGroupsId != null)
          return false;
      } else if (!this.matcherToGroupsId.equals(other.matcherToGroupsId))
        return false;
      if (this.customFilter == null) {
        if (other.customFilter != null)
          return false;
      } else if (!this.customFilter.equals(other.customFilter))
        return false;
      if (this.matchCompareFunctions == null) {
        if (other.matchCompareFunctions != null)
          return false;
      } else if (!this.matchCompareFunctions.equals(other.matchCompareFunctions))
        return false;
      if (this.methodFeatureMappings == null) {
        if (other.methodFeatureMappings != null)
          return false;
      } else if (!this.methodFeatureMappings.equals(other.methodFeatureMappings))
        return false;
      return true;
    }
    
    @Override
    @Pure
    public String toString() {
      ToStringBuilder b = new ToStringBuilder(this);
      b.add("ruleScope", this.ruleScope);
      b.add("groupKeyFunctions", this.groupKeyFunctions);
      b.add("matcherToGroupsId", this.matcherToGroupsId);
      b.add("customFilter", this.customFilter);
      b.add("matchCompareFunctions", this.matchCompareFunctions);
      b.add("methodFeatureMappings", this.methodFeatureMappings);
      return b.toString();
    }
    
    @Pure
    public IdentifierScope getRuleScope() {
      return this.ruleScope;
    }
    
    @Pure
    public ArrayList<String> getGroupKeyFunctions() {
      return this.groupKeyFunctions;
    }
    
    @Pure
    public Map<ClassMatcher, String> getMatcherToGroupsId() {
      return this.matcherToGroupsId;
    }
    
    @Pure
    public ArrayList<String> getCustomFilter() {
      return this.customFilter;
    }
    
    @Pure
    public ArrayList<String> getMatchCompareFunctions() {
      return this.matchCompareFunctions;
    }
    
    @Pure
    public ArrayList<FeatureMappingCompiler.Method> getMethodFeatureMappings() {
      return this.methodFeatureMappings;
    }
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Properties bxdProperties = new Properties();
    InputStream in = null;
    try {
      in = fsa.readBinaryFile("../BXtend.properties");
      bxdProperties.load(in);
    } catch (final Throwable _t) {
      if (_t instanceof IOException) {
        final IOException e = (IOException)_t;
        throw new RuntimeIOException("Loading the BXtend.properties file failed!", e);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    } finally {
      if ((in != null)) {
        try {
          in.close();
        } catch (final Throwable _t_1) {
          if (_t_1 instanceof IOException) {
          } else {
            throw Exceptions.sneakyThrow(_t_1);
          }
        }
      }
    }
    final String rootPackage = bxdProperties.getProperty("package");
    final String packagePath = rootPackage.replace(".", "/");
    final String trafo = bxdProperties.getProperty("trafo");
    final Properties modelsProperties = new Properties();
    boolean _isFile = fsa.isFile("../models.properties");
    if (_isFile) {
      in = null;
      try {
        in = fsa.readBinaryFile("../models.properties");
        modelsProperties.load(in);
      } catch (final Throwable _t) {
        if (_t instanceof IOException) {
          final IOException e = (IOException)_t;
          throw new RuntimeIOException("Loading the models.properties file failed!", e);
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      } finally {
        if ((in != null)) {
          try {
            in.close();
          } catch (final Throwable _t_1) {
            if (_t_1 instanceof IOException) {
            } else {
              throw Exceptions.sneakyThrow(_t_1);
            }
          }
        }
      }
    }
    this.featureMappingCompiler.setModelsProperties(modelsProperties);
    final String workspacePath = fsa.getURI("").toPlatformString(true);
    IWorkspaceRoot _root = ResourcesPlugin.getWorkspace().getRoot();
    Path _path = new Path(workspacePath);
    final IProject project = _root.getFolder(_path).getProject();
    EObject _get = resource.getContents().get(0);
    final BXtendDSL dsl = ((BXtendDSL) _get);
    try {
      IWorkspaceRoot _root_1 = ResourcesPlugin.getWorkspace().getRoot();
      Path _path_1 = new Path((workspacePath + "/../BXtend"));
      boolean _exists = _root_1.exists(_path_1);
      boolean _not = (!_exists);
      if (_not) {
        FrameworkGenerator.generate(project, bxdProperties, dsl);
      }
      this.regenerateGenFolder(project.getFolder("src-gen"), rootPackage);
      this.regenerateGenFolder(project.getFolder("xtend-gen"), rootPackage);
    } catch (final Throwable _t) {
      if (_t instanceof CoreException) {
        final CoreException e = (CoreException)_t;
        e.printStackTrace();
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    ArrayList<String> rules = new ArrayList<String>();
    final ArrayList<IFile> generatedXtendFiles = new ArrayList<IFile>();
    EList<TransformationRule> _rules = dsl.getRules();
    for (final TransformationRule rule : _rules) {
      {
        String _name = rule.getName();
        String _plus = ((packagePath + "/rules/") + _name);
        final String rulePathFsa = (_plus + ".xtend");
        fsa.generateFile(rulePathFsa, this.compile(rule, trafo, rootPackage));
        final Path rulePath = new Path(((workspacePath + "/") + rulePathFsa));
        IFile _file = ResourcesPlugin.getWorkspace().getRoot().getFile(rulePath);
        generatedXtendFiles.add(_file);
        boolean _anyAbstractMethod = this.anyAbstractMethod(rule);
        if (_anyAbstractMethod) {
          String _name_1 = rule.getName();
          String _plus_1 = ((("../src/" + packagePath) + "/rules/") + _name_1);
          final String ruleImplPathFsa = (_plus_1 + "Impl.xtend");
          final Path ruleImplPath = new Path(((workspacePath + "/") + ruleImplPathFsa));
          String _name_2 = rule.getName();
          String _plus_2 = (_name_2 + "Impl");
          rules.add(_plus_2);
          IFile _file_1 = ResourcesPlugin.getWorkspace().getRoot().getFile(ruleImplPath);
          generatedXtendFiles.add(_file_1);
          boolean _isFile_1 = fsa.isFile(ruleImplPathFsa);
          boolean _not = (!_isFile_1);
          if (_not) {
            fsa.generateFile(ruleImplPathFsa, RuleImplTemplate.getCode(rule.getName(), trafo, rootPackage));
            try {
              ResourcesPlugin.getWorkspace().getRoot().getFile(ruleImplPath).setDerived(false, null);
            } catch (final Throwable _t) {
              if (_t instanceof CoreException) {
                final CoreException e = (CoreException)_t;
                e.printStackTrace();
              } else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
          }
        } else {
          String _name_3 = rule.getName();
          rules.add(_name_3);
        }
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(workspacePath);
    _builder.append("/../BXtend/");
    _builder.append(packagePath);
    _builder.append("/trafo/Abstract");
    _builder.append(trafo);
    _builder.append(".xtend");
    final Path abstractEntryClassPath = new Path(_builder.toString());
    IFile _file = ResourcesPlugin.getWorkspace().getRoot().getFile(abstractEntryClassPath);
    generatedXtendFiles.add(_file);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append(workspacePath);
    _builder_1.append("/../BXtend/");
    _builder_1.append(packagePath);
    _builder_1.append("/rules/Elem2Elem.xtend");
    final Path baseClassPath = new Path(_builder_1.toString());
    IFile _file_1 = ResourcesPlugin.getWorkspace().getRoot().getFile(baseClassPath);
    generatedXtendFiles.add(_file_1);
    final String entryClassPathFsa = (((packagePath + "/trafo/") + trafo) + ".xtend");
    fsa.generateFile(entryClassPathFsa, EntryClassTemplate.getCode(dsl, trafo, rootPackage, rules));
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append(workspacePath);
    _builder_2.append("/");
    _builder_2.append(entryClassPathFsa);
    final Path entryClassPath = new Path(_builder_2.toString());
    IFile _file_2 = ResourcesPlugin.getWorkspace().getRoot().getFile(entryClassPath);
    generatedXtendFiles.add(_file_2);
    final ICoreRunnable _function = (IProgressMonitor it) -> {
      for (final IFile xtendFile : generatedXtendFiles) {
        try {
          boolean _exists = xtendFile.exists();
          if (_exists) {
            xtendFile.touch(null);
          }
        } catch (final Throwable _t) {
          if (_t instanceof CoreException) {
            final CoreException e = (CoreException)_t;
            e.printStackTrace();
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    };
    final Job job = Job.create("force Xtend compilation", _function);
    job.schedule();
  }
  
  @Inject
  @Extension
  private Utils _utils;
  
  @Inject
  private MatcherDataClassCompiler matcherDataClassCompiler;
  
  @Inject
  private ClassMatcherModifierCompiler classMatcherModifierCompiler;
  
  @Inject
  private CreationDeletionModifierCompiler creationDeletionCompiler;
  
  @Inject
  private CorrElemDefinitionCompiler corrElemDefinitionCompiler;
  
  @Inject
  private FeatureMappingCompiler featureMappingCompiler;
  
  private String compile(final TransformationRule rule, final String trafo, final String rootPackage) {
    final BXtendDSLGenerator.CompilationArtifacts artifacts = new BXtendDSLGenerator.CompilationArtifacts();
    artifacts.ruleScope.addIdentifier("CorrModelDelta", IdentifierScope.Group.CLASS);
    artifacts.ruleScope.addIdentifier("sourceToTarget", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("onTrgElemCreation", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("onTrgElemDeletion", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("targetToSource", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("onSrcElemCreation", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("onSrcElemDeletion", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("hasCorr", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getCorr", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getCorrElemPosition", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("assertRuleId", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("wrap", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("unwrap", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("updateOrCreateCorrSrc", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("updateOrCreateCorrTrg", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getOrCreateSrc", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getOrCreateTrg", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getSrcRoot", IdentifierScope.Group.METHOD);
    artifacts.ruleScope.addIdentifier("getTrgRoot", IdentifierScope.Group.METHOD);
    EObject _eContainer = rule.eContainer();
    final Metamodels metamodels = ((BXtendDSL) _eContainer).getMetamodels();
    Resource _xtrycatchfinallyexpression = null;
    try {
      _xtrycatchfinallyexpression = MetamodelLoader.load(metamodels.getSourcemodel(), metamodels.eResource().getResourceSet());
    } catch (final Throwable _t) {
      if (_t instanceof IOException) {
        final IOException e = (IOException)_t;
        throw new AssertionError("Validation should ensure the src metamodel can be loaded!", e);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    final Resource srcModel = _xtrycatchfinallyexpression;
    final EClass srcRootClass = this._utils.rootEClass(srcModel);
    Resource _xtrycatchfinallyexpression_1 = null;
    try {
      _xtrycatchfinallyexpression_1 = MetamodelLoader.load(metamodels.getTargetmodel(), metamodels.eResource().getResourceSet());
    } catch (final Throwable _t) {
      if (_t instanceof IOException) {
        final IOException e = (IOException)_t;
        throw new AssertionError("Validation should ensure the trg metamodel can be loaded!", e);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    final Resource trgModel = _xtrycatchfinallyexpression_1;
    final EClass trgRootClass = this._utils.rootEClass(trgModel);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(rootPackage);
    _builder.append(".rules;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import *");
    _builder.newLine();
    _builder.newLine();
    {
      boolean _anyAbstractMethod = this.anyAbstractMethod(rule);
      if (_anyAbstractMethod) {
        _builder.append("abstract ");
      }
    }
    _builder.append("class ");
    String _name = rule.getName();
    _builder.append(_name);
    _builder.append(" extends Elem2Elem {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("new(");
    _builder.append(trafo, "\t");
    _builder.append(" trafo) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("super(\"");
    String _name_1 = rule.getName();
    _builder.append(_name_1, "\t\t");
    _builder.append("\", trafo)");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override CorrModelDelta sourceToTarget(Set<EObject> _detachedCorrElems) {");
    _builder.newLine();
    _builder.append("\t\t");
    EList<SrcClassMatcher> _srcMatcher = rule.getSrcMatcher();
    EList<TrgClassMatcher> _trgMatcher = rule.getTrgMatcher();
    EList<FeatureMapping> _mappings = rule.getMappings();
    IdentifierScope _identifierScope = new IdentifierScope();
    String _compile = this.compile(true, _srcMatcher, _trgMatcher, _mappings, _identifierScope, artifacts);
    _builder.append(_compile, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    String _compile_1 = this.creationDeletionCompiler.compile(false, true, rule, artifacts.ruleScope);
    _builder.append(_compile_1, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override CorrModelDelta targetToSource(Set<EObject> _detachedCorrElems) {");
    _builder.newLine();
    _builder.append("\t\t");
    EList<SrcClassMatcher> _srcMatcher_1 = rule.getSrcMatcher();
    EList<TrgClassMatcher> _trgMatcher_1 = rule.getTrgMatcher();
    EList<FeatureMapping> _mappings_1 = rule.getMappings();
    IdentifierScope _identifierScope_1 = new IdentifierScope();
    String _compile_2 = this.compile(false, _srcMatcher_1, _trgMatcher_1, _mappings_1, _identifierScope_1, artifacts);
    _builder.append(_compile_2, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    String _compile_3 = this.creationDeletionCompiler.compile(true, false, rule, artifacts.ruleScope);
    _builder.append(_compile_3, "\t");
    _builder.newLineIfNotEmpty();
    {
      boolean _isEmpty = artifacts.groupKeyFunctions.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("\t");
        _builder.newLine();
        {
          for(final String keyFunction : artifacts.groupKeyFunctions) {
            _builder.append("\t");
            _builder.append(keyFunction, "\t");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      boolean _isEmpty_1 = artifacts.customFilter.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        _builder.append("\t");
        _builder.newLine();
        {
          for(final String filter : artifacts.customFilter) {
            _builder.append("\t");
            _builder.append(filter, "\t");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      boolean _isEmpty_2 = artifacts.matchCompareFunctions.isEmpty();
      boolean _not_2 = (!_isEmpty_2);
      if (_not_2) {
        _builder.append("\t");
        _builder.newLine();
        {
          for(final String compareFunction : artifacts.matchCompareFunctions) {
            _builder.append("\t");
            _builder.append(compareFunction, "\t");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      for(final FeatureMappingCompiler.Method method : artifacts.methodFeatureMappings) {
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        String _typeClass = method.getTypeClass();
        _builder.append(_typeClass, "\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        String _method = method.getMethod();
        _builder.append(_method, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    String _compile_4 = this.matcherDataClassCompiler.compile(rule.getSrcMatcher(), rule.getTrgMatcher(), artifacts.ruleScope);
    _builder.append(_compile_4, "\t");
    _builder.newLineIfNotEmpty();
    {
      if (((srcRootClass != null) || (trgRootClass != null))) {
        _builder.append("\t");
        _builder.newLine();
      }
    }
    {
      if ((srcRootClass != null)) {
        _builder.append("\t");
        _builder.append("def protected ");
        String _qualifiedName = this._utils.qualifiedName(srcRootClass);
        _builder.append(_qualifiedName, "\t");
        _builder.append(" getSrcRoot() {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (!sourceModel.contents.empty) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return sourceModel.contents.get(0) as ");
        String _qualifiedName_1 = this._utils.qualifiedName(srcRootClass);
        _builder.append(_qualifiedName_1, "\t\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} else {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return null");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    {
      if ((trgRootClass != null)) {
        _builder.append("\t");
        _builder.append("def protected ");
        String _qualifiedName_2 = this._utils.qualifiedName(trgRootClass);
        _builder.append(_qualifiedName_2, "\t");
        _builder.append(" getTrgRoot() {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (!targetModel.contents.empty) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return targetModel.contents.get(0) as ");
        String _qualifiedName_3 = this._utils.qualifiedName(trgRootClass);
        _builder.append(_qualifiedName_3, "\t\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} else {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return null");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder.toString().replace("import *", this.computeImports(rule, trafo, rootPackage));
  }
  
  private String compile(final boolean srcToTrg, final List<SrcClassMatcher> srcMatcher, final List<TrgClassMatcher> trgMatcher, final List<FeatureMapping> mappings, final IdentifierScope scope, final BXtendDSLGenerator.CompilationArtifacts artifacts) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if (srcToTrg) {
        _builder.append("Source");
      } else {
        _builder.append("Target");
      }
    }
    final String relSrc = _builder.toString();
    List<? extends ClassMatcher> _xifexpression = null;
    if (srcToTrg) {
      _xifexpression = srcMatcher;
    } else {
      _xifexpression = trgMatcher;
    }
    final List<? extends ClassMatcher> relSrcMatcher = _xifexpression;
    List<? extends ClassMatcher> _xifexpression_1 = null;
    if (srcToTrg) {
      _xifexpression_1 = trgMatcher;
    } else {
      _xifexpression_1 = srcMatcher;
    }
    final List<? extends ClassMatcher> relTrgMatcher = _xifexpression_1;
    final Function1<FeatureMapping, Boolean> _function = (FeatureMapping it) -> {
      boolean _xifexpression_2 = false;
      if (srcToTrg) {
        _xifexpression_2 = (Objects.equal(it.getDirection(), Direction.FWD) || Objects.equal(it.getDirection(), Direction.BX));
      } else {
        _xifexpression_2 = (Objects.equal(it.getDirection(), Direction.BWD) || Objects.equal(it.getDirection(), Direction.BX));
      }
      return Boolean.valueOf(_xifexpression_2);
    };
    final List<FeatureMapping> inDirectionMappings = IterableExtensions.<FeatureMapping>toList(IterableExtensions.<FeatureMapping>filter(mappings, _function));
    final Function1<ClassMatcher, Boolean> _function_1 = (ClassMatcher matcher) -> {
      final Function1<FeatureMapping, Boolean> _function_2 = (FeatureMapping it) -> {
        return Boolean.valueOf(this.featureMappingCompiler.anyUseOf(srcToTrg, it, matcher.getName()));
      };
      return Boolean.valueOf(IterableExtensions.<FeatureMapping>exists(inDirectionMappings, _function_2));
    };
    final List<? extends ClassMatcher> usedRelTrgMatcher = IterableExtensions.toList(IterableExtensions.filter(relTrgMatcher, _function_1));
    final ClassMatcherModifierCompiler.Group group = this.classMatcherModifierCompiler.compileGroupModifier(relSrcMatcher, artifacts.ruleScope, scope);
    Collection<String> _keyFunctions = group.getKeyFunctions();
    Iterables.<String>addAll(artifacts.groupKeyFunctions, _keyFunctions);
    Map<ClassMatcher, String> _matcherToGroupsId = group.getMatcherToGroupsId();
    artifacts.matcherToGroupsId.putAll(_matcherToGroupsId);
    final String groupDefinitions = group.getDefinitions();
    String _xifexpression_2 = null;
    final Function1<ClassMatcher, Boolean> _function_2 = (ClassMatcher it) -> {
      return Boolean.valueOf(it.getModifier().isSort());
    };
    boolean _exists = IterableExtensions.exists(relSrcMatcher, _function_2);
    if (_exists) {
      String _xblockexpression = null;
      {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("compare");
        _builder_1.append(relSrc);
        final String compareId = artifacts.ruleScope.addIdentifier(_builder_1.toString(), IdentifierScope.Group.METHOD);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("def protected abstract int ");
        _builder_2.append(compareId);
        _builder_2.append("(");
        _builder_2.append(relSrc);
        _builder_2.append(" lhs, ");
        _builder_2.append(relSrc);
        _builder_2.append(" rhs);");
        artifacts.matchCompareFunctions.add(_builder_2.toString());
        _xblockexpression = compareId;
      }
      _xifexpression_2 = _xblockexpression;
    }
    final String compareId = _xifexpression_2;
    scope.addIdentifier("_detachedCorrElems", IdentifierScope.Group.VARIABLE);
    scope.addIdentifier("_matches", IdentifierScope.Group.VARIABLE);
    scope.addIdentifier("_match", IdentifierScope.Group.VARIABLE);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("this.createdElems = new ArrayList<EObject>()");
    _builder_1.newLine();
    _builder_1.append("this.spareElems = new ArrayList<EObject>()");
    _builder_1.newLine();
    _builder_1.append("this.detachedCorrElems = _detachedCorrElems");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.newLine();
    _builder_1.append(groupDefinitions);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("val _matches = new ArrayList<");
    _builder_1.append(relSrc);
    _builder_1.append(">()");
    _builder_1.newLineIfNotEmpty();
    String _compile = this.compile(srcToTrg, 0, relSrcMatcher, scope, artifacts);
    _builder_1.append(_compile);
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    {
      final Function1<ClassMatcher, Boolean> _function_3 = (ClassMatcher it) -> {
        return Boolean.valueOf(it.getModifier().isSort());
      };
      boolean _exists_1 = IterableExtensions.exists(relSrcMatcher, _function_3);
      if (_exists_1) {
        _builder_1.append("_matches.sort([lhs, rhs | ");
        _builder_1.append(compareId);
        _builder_1.append("(lhs, rhs)])");
        _builder_1.newLineIfNotEmpty();
        _builder_1.newLine();
      }
    }
    _builder_1.append("for (_match : _matches) {");
    _builder_1.newLine();
    {
      for(final ClassMatcher matcher : relSrcMatcher) {
        _builder_1.append("\t");
        _builder_1.append("val ");
        String _name = matcher.getName();
        _builder_1.append(_name, "\t");
        _builder_1.append(" = _match.");
        String _name_1 = matcher.getName();
        _builder_1.append(_name_1, "\t");
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    String _compile_1 = this.corrElemDefinitionCompiler.compile(srcToTrg, relSrcMatcher, relTrgMatcher, usedRelTrgMatcher, scope);
    _builder_1.append(_compile_1, "\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t");
    String _compile_2 = this.compile(srcToTrg, inDirectionMappings, scope, artifacts);
    _builder_1.append(_compile_2, "\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("return new CorrModelDelta(this.createdElems, this.spareElems, this.detachedCorrElems)");
    _builder_1.newLine();
    return _builder_1.toString();
  }
  
  private String compile(final boolean srcToTrg, final int currentMatcher, final List<? extends ClassMatcher> matcher, final IdentifierScope scope, final BXtendDSLGenerator.CompilationArtifacts artifacts) {
    int _size = matcher.size();
    boolean _greaterEqualsThan = (currentMatcher >= _size);
    if (_greaterEqualsThan) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("_matches += new ");
      {
        if (srcToTrg) {
          _builder.append("Source");
        } else {
          _builder.append("Target");
        }
      }
      _builder.append("(");
      final Function1<ClassMatcher, String> _function = (ClassMatcher it) -> {
        return it.getName();
      };
      String _join = IterableExtensions.join(ListExtensions.map(matcher, _function), ", ");
      _builder.append(_join);
      _builder.append(")");
      return _builder.toString();
    }
    final ClassMatcher current = matcher.get(currentMatcher);
    final List<? extends ClassMatcher> before = matcher.subList(0, currentMatcher);
    final ClassMatcherModifierCompiler.Filter filter = this.classMatcherModifierCompiler.compileFilterModifier(current, before, artifacts.ruleScope);
    String _filter = filter.getFilter();
    boolean _tripleNotEquals = (_filter != null);
    if (_tripleNotEquals) {
      String _filter_1 = filter.getFilter();
      artifacts.customFilter.add(_filter_1);
    }
    scope.addIdentifier(current.getName(), IdentifierScope.Group.VARIABLE);
    String _xifexpression = null;
    if (srcToTrg) {
      _xifexpression = "sourceModel";
    } else {
      _xifexpression = "targetModel";
    }
    final String model = _xifexpression;
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("for (");
    String _name = current.getName();
    _builder_1.append(_name);
    _builder_1.append(" : ");
    {
      boolean _containsKey = artifacts.matcherToGroupsId.containsKey(current);
      boolean _not = (!_containsKey);
      if (_not) {
        _builder_1.append(model);
        _builder_1.append(".allContents.filter(typeof(");
        String _qualifiedName = this._utils.qualifiedName(current.getClazz());
        _builder_1.append(_qualifiedName);
        _builder_1.append("))");
        String _call = filter.getCall();
        _builder_1.append(_call);
        _builder_1.append(".toIterable()) {");
        _builder_1.newLineIfNotEmpty();
      } else {
        String _get = artifacts.matcherToGroupsId.get(current);
        _builder_1.append(_get);
        String _call_1 = filter.getCall();
        _builder_1.append(_call_1);
        _builder_1.append(") {");
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("\t");
    String _compile = this.compile(srcToTrg, (currentMatcher + 1), matcher, scope, artifacts);
    _builder_1.append(_compile, "\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("}");
    _builder_1.newLine();
    return _builder_1.toString();
  }
  
  private String compile(final boolean srcToTrg, final List<FeatureMapping> inDirectionMappings, final IdentifierScope scope, final BXtendDSLGenerator.CompilationArtifacts artifacts) {
    String _xblockexpression = null;
    {
      ArrayList<String> compiledMappings = new ArrayList<String>();
      boolean lastCompiledToAssignment = false;
      for (final FeatureMapping mapping : inDirectionMappings) {
        boolean _compileableToAssignment = this.featureMappingCompiler.compileableToAssignment(srcToTrg, mapping);
        if (_compileableToAssignment) {
          if ((!lastCompiledToAssignment)) {
            String _lineSeparator = System.lineSeparator();
            compiledMappings.add(_lineSeparator);
            lastCompiledToAssignment = true;
          }
          String _compileToAssignment = this.featureMappingCompiler.compileToAssignment(srcToTrg, mapping, scope);
          compiledMappings.add(_compileToAssignment);
        } else {
          final FeatureMappingCompiler.Method method = this.featureMappingCompiler.compileToMethod(srcToTrg, mapping, artifacts.ruleScope, scope);
          String _lineSeparator_1 = System.lineSeparator();
          compiledMappings.add(_lineSeparator_1);
          String _call = method.getCall();
          compiledMappings.add(_call);
          artifacts.methodFeatureMappings.add(method);
        }
      }
      _xblockexpression = IterableExtensions.join(compiledMappings);
    }
    return _xblockexpression;
  }
  
  private void regenerateGenFolder(final IFolder genFolder, final String rootPackage) throws CoreException {
    boolean _exists = genFolder.exists();
    boolean _not = (!_exists);
    if (_not) {
      genFolder.create(true, true, null);
    }
    genFolder.setDerived(true, null);
    IResource[] _members = genFolder.members();
    for (final IResource member : _members) {
      member.delete(true, null);
    }
    IFolder packageSegment = genFolder;
    String[] _split = rootPackage.split("\\.");
    for (final String segmentString : _split) {
      {
        packageSegment = packageSegment.getFolder(segmentString);
        packageSegment.create(true, true, null);
        packageSegment.setDerived(true, null);
      }
    }
    packageSegment.getFolder("rules").create(true, true, null);
    packageSegment.getFolder("rules").setDerived(true, null);
    packageSegment.getFolder("trafo").create(true, true, null);
    packageSegment.getFolder("trafo").setDerived(true, null);
  }
  
  private String computeImports(final TransformationRule rule, final String trafo, final String rootPackage) {
    String _xblockexpression = null;
    {
      HashSet<String> imports = new HashSet<String>();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("import ");
      _builder.append(rootPackage);
      _builder.append(".rules.Elem2Elem");
      imports.add(_builder.toString());
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("import ");
      _builder_1.append(rootPackage);
      _builder_1.append(".trafo.");
      _builder_1.append(trafo);
      imports.add(_builder_1.toString());
      imports.add("import java.util.Set");
      imports.add("import org.eclipse.emf.ecore.EObject");
      imports.add("import java.util.ArrayList");
      Set<String> _neededImports = this.classMatcherModifierCompiler.neededImports(rule.getSrcMatcher());
      Iterables.<String>addAll(imports, _neededImports);
      Set<String> _neededImports_1 = this.classMatcherModifierCompiler.neededImports(rule.getTrgMatcher());
      Iterables.<String>addAll(imports, _neededImports_1);
      Set<String> _neededImports_2 = this.creationDeletionCompiler.neededImports(true, true, rule);
      Iterables.<String>addAll(imports, _neededImports_2);
      final Function1<FeatureMapping, Set<String>> _function = (FeatureMapping it) -> {
        return this.featureMappingCompiler.neededImports(true, it, rootPackage);
      };
      Iterable<String> _flatten = Iterables.<String>concat(IterableExtensions.<FeatureMapping, Set<String>>map(this.directionalMappings(true, rule), _function));
      Iterables.<String>addAll(imports, _flatten);
      final Function1<FeatureMapping, Set<String>> _function_1 = (FeatureMapping it) -> {
        return this.featureMappingCompiler.neededImports(false, it, rootPackage);
      };
      Iterable<String> _flatten_1 = Iterables.<String>concat(IterableExtensions.<FeatureMapping, Set<String>>map(this.directionalMappings(false, rule), _function_1));
      Iterables.<String>addAll(imports, _flatten_1);
      Set<String> _neededImports_3 = this.matcherDataClassCompiler.neededImports(rootPackage);
      Iterables.<String>addAll(imports, _neededImports_3);
      Set<String> _neededImports_4 = this.corrElemDefinitionCompiler.neededImports(rootPackage);
      Iterables.<String>addAll(imports, _neededImports_4);
      _xblockexpression = IterableExtensions.join(IterableExtensions.<String>sort(imports), System.lineSeparator());
    }
    return _xblockexpression;
  }
  
  private boolean anyAbstractMethod(final TransformationRule rule) {
    return ((((this.classMatcherModifierCompiler.anyAbstractMethod(rule.getSrcMatcher()) || this.classMatcherModifierCompiler.anyAbstractMethod(rule.getTrgMatcher())) || this.creationDeletionCompiler.anyAbstractMethod(true, true, rule)) || IterableExtensions.<FeatureMapping>exists(this.directionalMappings(true, rule), ((Function1<FeatureMapping, Boolean>) (FeatureMapping it) -> {
      return Boolean.valueOf(this.featureMappingCompiler.anyAbstractMethod(true, it));
    }))) || IterableExtensions.<FeatureMapping>exists(this.directionalMappings(false, rule), ((Function1<FeatureMapping, Boolean>) (FeatureMapping it) -> {
      return Boolean.valueOf(this.featureMappingCompiler.anyAbstractMethod(false, it));
    })));
  }
  
  private Iterable<FeatureMapping> directionalMappings(final boolean srcToTrg, final TransformationRule rule) {
    final Function1<FeatureMapping, Boolean> _function = (FeatureMapping it) -> {
      boolean _xifexpression = false;
      if (srcToTrg) {
        _xifexpression = (Objects.equal(it.getDirection(), Direction.FWD) || Objects.equal(it.getDirection(), Direction.BX));
      } else {
        _xifexpression = (Objects.equal(it.getDirection(), Direction.BWD) || Objects.equal(it.getDirection(), Direction.BX));
      }
      return Boolean.valueOf(_xifexpression);
    };
    return IterableExtensions.<FeatureMapping>filter(rule.getMappings(), _function);
  }
}
