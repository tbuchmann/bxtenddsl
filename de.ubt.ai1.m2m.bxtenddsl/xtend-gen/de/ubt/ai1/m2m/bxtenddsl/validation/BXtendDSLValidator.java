/**
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.inject.Inject;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSLPackage;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.ClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Config;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Correspondence;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Direction;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.FeatureMapping;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.MappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Metamodels;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcMappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgClassMatcher;
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgMappingFeature;
import de.ubt.ai1.m2m.bxtenddsl.utils.MetamodelLoader;
import de.ubt.ai1.m2m.bxtenddsl.utils.Utils;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXtendDSLValidator extends AbstractBXtendDSLValidator {
  public static final String METAMODEL_NOT_RESOLVABLE = "metamodelNotResolvable";
  
  public static final String LOADING_METAMODEL_FAILED = "loadingMetamodelFailed";
  
  public static final String METAMODEL_NOT_APPLICABLE = "metamodelNotApplicable";
  
  public static final String FORBIDDEN_OPTION_NAME = "forbiddenOptionName";
  
  public static final String AMBIGUOUS_OPTION_NAME = "ambiguousOptionName";
  
  public static final String FORBIDDEN_RULE_NAME = "forbiddenRuleName";
  
  public static final String AMBIGUOUS_RULE_NAME = "ambiguousRuleName";
  
  public static final String FORBIDDEN_CLASS_MATCHER_NAME = "forbiddenClassMatcherName";
  
  public static final String AMBIGUOUS_CLASS_MATCHER_NAME = "ambiguousClassMatcherName";
  
  public static final String DUPLICATED_MAPPING_PARAM = "duplicatedMappingParam";
  
  public static final String MAPPING_PARAM_ALREADY_SET = "mappingParamAlreadySet";
  
  public static final String UNCHANGEABLE_MAPPING_FEATURE = "unchangeableMappingFeature";
  
  public static final String ATTRIBUTE_CORR_MAPPING_FEATURE = "attributeCorrMappingFeature";
  
  public static final String DUPLICATED_CORR_MAPPING_RULE = "duplicatedCorrMappingRule";
  
  public static final String UNRESOLVABLE_CORR_MAPPING_RULE = "unresolvableCorrMappingRule";
  
  public static final String CORR_MAPPING_RULE_BEFORE_RULE = "corrMappingRuleBeforeRule";
  
  public static final String DUPLICATED_CORR_MAPPING_MATCHER = "duplicatedCorrMappingMatcher";
  
  public static final String FORBIDDEN_CLASS_MAPPING_PARAM = "forbiddenClassMappingParam";
  
  public static final String NO_OUT_MAPPING_PARAM = "noOutMappingParam";
  
  /**
   * Checks if the sourcemodel uri is resolvable, can be loaded and applied as metamodel.
   */
  @Check
  public void checkSourcemodelUri(final Metamodels metamodels) {
    this.checkMetamodelUri(metamodels, BXtendDSLPackage.Literals.METAMODELS__SOURCEMODEL, metamodels.getSourcemodel());
  }
  
  /**
   * Checks if the targetmodel uri is resolvable, can be loaded and applied as metamodel.
   */
  @Check
  public void checkTargetmodelUri(final Metamodels metamodels) {
    this.checkMetamodelUri(metamodels, BXtendDSLPackage.Literals.METAMODELS__TARGETMODEL, metamodels.getTargetmodel());
  }
  
  @Check
  public void checkForbiddenOptionName(final Config config) {
    for (int i = 0; (i < config.getOptions().size()); i++) {
      boolean _matches = config.getOptions().get(i).matches("[A-Z][A-Z_\\d]*");
      boolean _not = (!_matches);
      if (_not) {
        String _get = config.getOptions().get(i);
        String _plus = ("\'" + _get);
        final String cause = (_plus + "\'.");
        String _xifexpression = null;
        boolean _matches_1 = config.getOptions().get(i).matches("[A-Z_\\d]*");
        boolean _not_1 = (!_matches_1);
        if (_not_1) {
          _xifexpression = " Only upper case letters, digits and underscores are allowed.";
        } else {
          _xifexpression = " The first character must be an upper case letter.";
        }
        final String details = _xifexpression;
        final EAttribute feature = BXtendDSLPackage.Literals.CONFIG__OPTIONS;
        this.error((("Forbidden option name: " + cause) + details), feature, i, BXtendDSLValidator.FORBIDDEN_OPTION_NAME);
      }
    }
  }
  
  @Check
  public void checkAmbigiuousOptionName(final Config config) {
    for (int i = 0; (i < config.getOptions().size()); i++) {
      {
        final String option = config.getOptions().get(i);
        final Function1<String, Boolean> _function = (String it) -> {
          return Boolean.valueOf(Objects.equal(it, option));
        };
        int _size = IterableExtensions.size(IterableExtensions.<String>filter(config.getOptions(), _function));
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          final EAttribute feature = BXtendDSLPackage.Literals.CONFIG__OPTIONS;
          String _get = config.getOptions().get(i);
          String _plus = ("Ambiguous option name: \'" + _get);
          String _plus_1 = (_plus + "\'");
          this.error(_plus_1, feature, i, BXtendDSLValidator.AMBIGUOUS_OPTION_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkRuleNameNotForbidden(final TransformationRule rule) {
    final EAttribute feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__NAME;
    String _name = rule.getName();
    boolean _equals = Objects.equal(_name, "Elem2Elem");
    if (_equals) {
      final String cause = "\'Elem2Elem\' is the name of the base class for transformation rules!";
      this.error(("Forbidden rule name: " + cause), feature, BXtendDSLValidator.FORBIDDEN_RULE_NAME);
    } else {
      boolean _endsWith = rule.getName().endsWith("Impl");
      if (_endsWith) {
        final String cause_1 = "Rule names ending with \'Impl\' are reserved for rule specialization!";
        this.error(("Forbidden rule name: " + cause_1), feature, BXtendDSLValidator.FORBIDDEN_RULE_NAME);
      }
    }
  }
  
  @Check
  public void checkRuleNameUnique(final TransformationRule rule) {
    EObject _eContainer = rule.eContainer();
    final Function1<TransformationRule, Boolean> _function = (TransformationRule it) -> {
      String _name = it.getName();
      String _name_1 = rule.getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    int _size = IterableExtensions.size(IterableExtensions.<TransformationRule>filter(((BXtendDSL) _eContainer).getRules(), _function));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final EAttribute feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__NAME;
      String _name = rule.getName();
      String _plus = ("\'" + _name);
      final String cause = (_plus + "\'");
      this.error(("Ambiguous rule name: " + cause), feature, BXtendDSLValidator.AMBIGUOUS_RULE_NAME);
    }
  }
  
  @Check
  public void checkClassMatcherNameNotForbidden(final ClassMatcher matcher) {
    boolean _startsWith = matcher.getName().startsWith("_");
    if (_startsWith) {
      final EAttribute feature = BXtendDSLPackage.Literals.CLASS_MATCHER__NAME;
      final String cause = "Class matcher names may not start with an underscore!";
      this.error(("Forbidden class matcher name: " + cause), feature, BXtendDSLValidator.FORBIDDEN_CLASS_MATCHER_NAME);
    }
  }
  
  @Check
  public void checkClassMatcherNameUnique(final ClassMatcher matcher) {
    ArrayList<ClassMatcher> allMatcher = new ArrayList<ClassMatcher>();
    EObject _eContainer = matcher.eContainer();
    EList<SrcClassMatcher> _srcMatcher = ((TransformationRule) _eContainer).getSrcMatcher();
    Iterables.<ClassMatcher>addAll(allMatcher, _srcMatcher);
    EObject _eContainer_1 = matcher.eContainer();
    EList<TrgClassMatcher> _trgMatcher = ((TransformationRule) _eContainer_1).getTrgMatcher();
    Iterables.<ClassMatcher>addAll(allMatcher, _trgMatcher);
    final Function1<ClassMatcher, Boolean> _function = (ClassMatcher it) -> {
      String _name = it.getName();
      String _name_1 = matcher.getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    int _size = IterableExtensions.size(IterableExtensions.<ClassMatcher>filter(allMatcher, _function));
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final EAttribute feature = BXtendDSLPackage.Literals.CLASS_MATCHER__NAME;
      String _name = matcher.getName();
      String _plus = ("\'" + _name);
      final String cause = (_plus + "\'");
      this.error(("Ambiguous class matcher name: " + cause), feature, BXtendDSLValidator.AMBIGUOUS_CLASS_MATCHER_NAME);
    }
  }
  
  @Check
  public void checkDuplicatedMappingParam(final FeatureMapping mapping) {
    this.checkDuplicatedMappingFeature(mapping.getSrcFeatures(), BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES);
    this.checkDuplicatedMappingFeature(mapping.getTrgFeatures(), BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES);
    this.checkDuplicatedMappingClass(mapping.getSrcClasses(), BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES);
    this.checkDuplicatedMappingClass(mapping.getTrgClasses(), BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES);
  }
  
  @Check
  public void checkUnchangeableMappingFeature(final FeatureMapping mapping) {
    if ((Objects.equal(mapping.getDirection(), Direction.BWD) || Objects.equal(mapping.getDirection(), Direction.BX))) {
      for (int i = 0; (i < mapping.getSrcFeatures().size()); i++) {
        boolean _isChangeable = mapping.getSrcFeatures().get(i).getFeature().isChangeable();
        boolean _not = (!_isChangeable);
        if (_not) {
          final String token = this._utils.token(mapping.getSrcFeatures().get(i));
          final String cause = (("\'" + token) + "\'. It must not be used as out parameter of a mapping.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES;
          this.error(("Unchangeable mapping feature: " + cause), feature, i, BXtendDSLValidator.UNCHANGEABLE_MAPPING_FEATURE);
        }
      }
    }
    if ((Objects.equal(mapping.getDirection(), Direction.FWD) || Objects.equal(mapping.getDirection(), Direction.BX))) {
      for (int i = 0; (i < mapping.getTrgFeatures().size()); i++) {
        boolean _isChangeable = mapping.getTrgFeatures().get(i).getFeature().isChangeable();
        boolean _not = (!_isChangeable);
        if (_not) {
          final String token = this._utils.token(mapping.getTrgFeatures().get(i));
          final String cause = (("\'" + token) + "\'. It must not be used as out parameter of a mapping.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES;
          this.error(("Unchangeable mapping feature: " + cause), feature, i, BXtendDSLValidator.UNCHANGEABLE_MAPPING_FEATURE);
        }
      }
    }
  }
  
  @Check
  public void checkMappingParamAlreadySet(final FeatureMapping mapping) {
    HashSet<String> setBeforeParams = new HashSet<String>();
    EObject _eContainer = mapping.eContainer();
    final Function1<FeatureMapping, Boolean> _function = (FeatureMapping it) -> {
      return Boolean.valueOf((!Objects.equal(it, mapping)));
    };
    Iterable<FeatureMapping> _takeWhile = IterableExtensions.<FeatureMapping>takeWhile(((TransformationRule) _eContainer).getMappings(), _function);
    for (final FeatureMapping mappingBefore : _takeWhile) {
      List<String> _outParams = this.outParams(mappingBefore);
      Iterables.<String>addAll(setBeforeParams, _outParams);
    }
    final List<String> outParams = this.outParams(mapping);
    for (int i = 0; (i < mapping.getSrcFeatures().size()); i++) {
      {
        final String token = this._utils.token(mapping.getSrcFeatures().get(i));
        if ((outParams.contains(token) && setBeforeParams.contains(token))) {
          final String cause = (("\'" + token) + "\'. This assignment overwrites the previous assignment.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES;
          this.warning(("Mapping parameter already set: " + cause), feature, i, BXtendDSLValidator.MAPPING_PARAM_ALREADY_SET);
        }
      }
    }
    for (int i = 0; (i < mapping.getTrgFeatures().size()); i++) {
      {
        final String token = this._utils.token(mapping.getTrgFeatures().get(i));
        if ((outParams.contains(token) && setBeforeParams.contains(token))) {
          final String cause = (("\'" + token) + "\'. This assignment overwrites the previous assignment.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES;
          this.warning(("Mapping parameter already set: " + cause), feature, i, BXtendDSLValidator.MAPPING_PARAM_ALREADY_SET);
        }
      }
    }
    for (int i = 0; (i < mapping.getSrcClasses().size()); i++) {
      ClassMatcher _get = mapping.getSrcClasses().get(i);
      if ((_get instanceof SrcClassMatcher)) {
        final String matcher = mapping.getSrcClasses().get(i).getName();
        if ((outParams.contains(matcher) && setBeforeParams.contains(matcher))) {
          final String cause = (("\'" + matcher) + "\'. This assignment overwrites the previous assignment.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES;
          this.warning(("Mapping parameter already set: " + cause), feature, i, BXtendDSLValidator.MAPPING_PARAM_ALREADY_SET);
        }
      }
    }
    for (int i = 0; (i < mapping.getTrgClasses().size()); i++) {
      ClassMatcher _get = mapping.getTrgClasses().get(i);
      if ((_get instanceof TrgClassMatcher)) {
        final String matcher = mapping.getTrgClasses().get(i).getName();
        if ((outParams.contains(matcher) && setBeforeParams.contains(matcher))) {
          final String cause = (("\'" + matcher) + "\'. This assignment overwrites the previous assignment.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES;
          this.warning(("Mapping parameter already set: " + cause), feature, i, BXtendDSLValidator.MAPPING_PARAM_ALREADY_SET);
        }
      }
    }
  }
  
  @Check
  public void checkAttributeCorrMappingFeature(final MappingFeature mappingFeature) {
    if ((mappingFeature.isCorr() && (mappingFeature.getFeature() instanceof EAttribute))) {
      String _ken = this._utils.token(mappingFeature);
      String _plus = ("\'{" + _ken);
      final String cause = (_plus + " : ...}\'. Correspondences can only be resolved for references!");
      final EReference feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__FEATURE;
      this.error(("Attribute corr mapping feature: " + cause), feature, BXtendDSLValidator.ATTRIBUTE_CORR_MAPPING_FEATURE);
    }
  }
  
  @Check
  public void checkDuplicatedCorrMappingRule(final MappingFeature mappingFeature) {
    for (int i = 0; (i < mappingFeature.getCorrs().size()); i++) {
      {
        final TransformationRule rule = mappingFeature.getCorrs().get(i).getRule();
        final Function1<Correspondence, Boolean> _function = (Correspondence it) -> {
          TransformationRule _rule = it.getRule();
          return Boolean.valueOf(Objects.equal(_rule, rule));
        };
        int _size = IterableExtensions.size(IterableExtensions.<Correspondence>filter(mappingFeature.getCorrs(), _function));
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          String _name = rule.getName();
          String _plus = ("Duplicated corr mapping rule: \'" + _name);
          final String message = (_plus + "\'");
          final EReference feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS;
          this.error(message, feature, i, BXtendDSLValidator.DUPLICATED_CORR_MAPPING_RULE);
        }
      }
    }
  }
  
  @Check
  public void checkUnresolvableCorrMappingRule(final MappingFeature mappingFeature) {
    EClassifier _eType = mappingFeature.getFeature().getEType();
    boolean _not = (!(_eType instanceof EClass));
    if (_not) {
      return;
    }
    EClassifier _eType_1 = mappingFeature.getFeature().getEType();
    final EClass featureEClass = ((EClass) _eType_1);
    for (int i = 0; (i < mappingFeature.getCorrs().size()); i++) {
      {
        final TransformationRule rule = mappingFeature.getCorrs().get(i).getRule();
        EList<? extends ClassMatcher> _xifexpression = null;
        if ((mappingFeature instanceof SrcMappingFeature)) {
          _xifexpression = rule.getSrcMatcher();
        } else {
          _xifexpression = rule.getTrgMatcher();
        }
        final EList<? extends ClassMatcher> matchers = _xifexpression;
        final Function1<ClassMatcher, Boolean> _function = (ClassMatcher it) -> {
          return Boolean.valueOf((it.getClazz().isSuperTypeOf(featureEClass) || featureEClass.isSuperTypeOf(it.getClazz())));
        };
        boolean _exists = IterableExtensions.exists(matchers, _function);
        boolean _not_1 = (!_exists);
        if (_not_1) {
          final String message = "Unresolvable corr mapping rule: ";
          String _xifexpression_1 = null;
          if ((mappingFeature instanceof SrcMappingFeature)) {
            _xifexpression_1 = "src matcher";
          } else {
            _xifexpression_1 = "trg matcher";
          }
          final String matcher = _xifexpression_1;
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("No ");
          _builder.append(matcher);
          _builder.append(" of \'");
          String _name = rule.getName();
          _builder.append(_name);
          _builder.append("\' fits to the type of \'");
          String _ken = this._utils.token(mappingFeature);
          _builder.append(_ken);
          _builder.append("\'.");
          final String hint = _builder.toString();
          final EReference feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS;
          this.error((message + hint), feature, i, BXtendDSLValidator.UNRESOLVABLE_CORR_MAPPING_RULE);
        }
      }
    }
  }
  
  @Check
  public void checkCorrMappingRuleBeforeRule(final MappingFeature mappingFeature) {
    final EList<TransformationRule> rules = EcoreUtil2.<BXtendDSL>getContainerOfType(mappingFeature, BXtendDSL.class).getRules();
    final TransformationRule featureRule = EcoreUtil2.<TransformationRule>getContainerOfType(mappingFeature, TransformationRule.class);
    for (int i = 0; (i < mappingFeature.getCorrs().size()); i++) {
      {
        final TransformationRule corrRule = mappingFeature.getCorrs().get(i).getRule();
        int _indexOf = rules.indexOf(featureRule);
        int _indexOf_1 = rules.indexOf(corrRule);
        boolean _lessThan = (_indexOf < _indexOf_1);
        if (_lessThan) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("\'");
          String _name = corrRule.getName();
          _builder.append(_name);
          _builder.append("\' can\'t be resolved, because it is executed after \'");
          String _name_1 = featureRule.getName();
          _builder.append(_name_1);
          _builder.append("\'.");
          final String hint = _builder.toString();
          final EReference feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS;
          this.error(("Corr mapping rule before rule: " + hint), feature, i, BXtendDSLValidator.CORR_MAPPING_RULE_BEFORE_RULE);
        }
      }
    }
  }
  
  @Check
  public void checkDuplicatedCorrMappingMatcher(final Correspondence corr) {
    for (int i = 0; (i < corr.getMatchers().size()); i++) {
      {
        final ClassMatcher matcher = corr.getMatchers().get(i);
        final Function1<ClassMatcher, Boolean> _function = (ClassMatcher it) -> {
          return Boolean.valueOf(Objects.equal(it, matcher));
        };
        int _size = IterableExtensions.size(IterableExtensions.<ClassMatcher>filter(corr.getMatchers(), _function));
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          String _name = matcher.getName();
          String _plus = ("Duplicated corr mapping matcher: \'" + _name);
          final String message = (_plus + "\'");
          final EReference feature = BXtendDSLPackage.Literals.CORRESPONDENCE__MATCHERS;
          this.error(message, feature, i, BXtendDSLValidator.DUPLICATED_CORR_MAPPING_MATCHER);
        }
      }
    }
  }
  
  @Check
  public void checkForbiddenClassMappingParam(final FeatureMapping featureMapping) {
    for (int i = 0; (i < featureMapping.getSrcClasses().size()); i++) {
      {
        final ClassMatcher matcher = featureMapping.getSrcClasses().get(i);
        if (((!matcher.getModifier().isGroup()) && (matcher instanceof SrcClassMatcher))) {
          String _name = matcher.getName();
          String _plus = ("\'" + _name);
          String _plus_1 = (_plus + "\'. Features of not grouped src class parameters must be accessed");
          final String cause = (_plus_1 + " directly on this rule side.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES;
          this.error(("Forbidden class mapping parameter: " + cause), feature, i, BXtendDSLValidator.FORBIDDEN_CLASS_MAPPING_PARAM);
        }
      }
    }
    for (int i = 0; (i < featureMapping.getTrgClasses().size()); i++) {
      {
        final ClassMatcher matcher = featureMapping.getTrgClasses().get(i);
        if (((!matcher.getModifier().isGroup()) && (matcher instanceof TrgClassMatcher))) {
          String _name = matcher.getName();
          String _plus = ("\'" + _name);
          String _plus_1 = (_plus + "\'. Features of not grouped trg class parameters must be accessed");
          final String cause = (_plus_1 + " directly on this rule side.");
          final EReference feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES;
          this.error(("Forbidden class mapping parameter: " + cause), feature, i, BXtendDSLValidator.FORBIDDEN_CLASS_MAPPING_PARAM);
        }
      }
    }
  }
  
  @Check
  public void checkNoOutMappingParam(final TransformationRule rule) {
    for (int i = 0; (i < rule.getMappings().size()); i++) {
      {
        final FeatureMapping mapping = rule.getMappings().get(i);
        final Direction direction = mapping.getDirection();
        if (((Objects.equal(direction, Direction.BWD) || Objects.equal(direction, Direction.BX)) && this.outSrcParams(mapping).isEmpty())) {
          final String cause = "Direction <-- is specified, but the lhs contains no out parameter!";
          final EReference feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__MAPPINGS;
          this.error(("No out mapping parameter: " + cause), feature, i, BXtendDSLValidator.NO_OUT_MAPPING_PARAM);
        }
        if (((Objects.equal(direction, Direction.FWD) || Objects.equal(direction, Direction.BX)) && this.outTrgParams(mapping).isEmpty())) {
          final String cause_1 = "Direction --> is specified, but the rhs contains no out parameter!";
          final EReference feature_1 = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__MAPPINGS;
          this.error(("No out mapping parameter: " + cause_1), feature_1, i, BXtendDSLValidator.NO_OUT_MAPPING_PARAM);
        }
      }
    }
  }
  
  @Inject
  @Extension
  private Utils _utils;
  
  private void checkMetamodelUri(final Metamodels container, final EAttribute feature, final String metamodel) {
    final Resource metamodelRes = this.loadMetamodel(container, feature, metamodel, false);
    if ((metamodelRes == null)) {
      return;
    }
    final Set<String> referencedMetamodels = CollectionLiterals.<String>newHashSet();
    Iterable<EClass> _iterable = IteratorExtensions.<EClass>toIterable(Iterators.<EClass>filter(metamodelRes.getAllContents(), EClass.class));
    for (final EClass class_ : _iterable) {
      {
        final ArrayList<EClass> referencedClasses = CollectionLiterals.<EClass>newArrayList();
        Iterable<EClass> _filter = Iterables.<EClass>filter(class_.getEAllSuperTypes(), EClass.class);
        Iterables.<EClass>addAll(referencedClasses, _filter);
        final Function1<EStructuralFeature, EClassifier> _function = (EStructuralFeature it) -> {
          return it.getEType();
        };
        Iterable<EClass> _filter_1 = Iterables.<EClass>filter(ListExtensions.<EStructuralFeature, EClassifier>map(class_.getEAllStructuralFeatures(), _function), EClass.class);
        Iterables.<EClass>addAll(referencedClasses, _filter_1);
        final Function1<EClass, Boolean> _function_1 = (EClass it) -> {
          EObject _rootContainer = EcoreUtil2.getRootContainer(it);
          return Boolean.valueOf((!(_rootContainer instanceof EPackage)));
        };
        boolean _exists = IterableExtensions.<EClass>exists(referencedClasses, _function_1);
        if (_exists) {
          final Function1<EClass, Boolean> _function_2 = (EClass it) -> {
            EObject _rootContainer = EcoreUtil2.getRootContainer(it);
            return Boolean.valueOf((!(_rootContainer instanceof EPackage)));
          };
          final EClass eclass = IterableExtensions.<EClass>findFirst(referencedClasses, _function_2);
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The root container of EClass \'");
          _builder.append(eclass);
          _builder.append("\' is no EPackage!");
          this.error(_builder.toString(), feature);
        }
        final Function1<EClass, EObject> _function_3 = (EClass it) -> {
          return EcoreUtil2.getRootContainer(it);
        };
        final Function1<EPackage, String> _function_4 = (EPackage it) -> {
          return it.getNsURI();
        };
        final Function1<String, Boolean> _function_5 = (String it) -> {
          return Boolean.valueOf((!Objects.equal(it, metamodel)));
        };
        Iterable<String> _filter_2 = IterableExtensions.<String>filter(IterableExtensions.<EPackage, String>map(Iterables.<EPackage>filter(ListExtensions.<EClass, EObject>map(referencedClasses, _function_3), EPackage.class), _function_4), _function_5);
        Iterables.<String>addAll(referencedMetamodels, _filter_2);
      }
    }
    for (final String referencedMetamodel : referencedMetamodels) {
      this.loadMetamodel(container, feature, metamodel, true);
    }
  }
  
  private Resource loadMetamodel(final Metamodels container, final EAttribute feature, final String metamodel, final boolean referenced) {
    if ((metamodel == null)) {
      return null;
    }
    String _xifexpression = null;
    if (referenced) {
      _xifexpression = (("referenced metamodel \'" + metamodel) + "\'");
    } else {
      _xifexpression = "metamodel";
    }
    final String modelDescr = _xifexpression;
    Resource _xtrycatchfinallyexpression = null;
    try {
      _xtrycatchfinallyexpression = MetamodelLoader.load(metamodel, container.eResource().getResourceSet());
    } catch (final Throwable _t) {
      if (_t instanceof IOException) {
        final IOException e = (IOException)_t;
        String _firstUpper = StringExtensions.toFirstUpper(modelDescr);
        String _plus = (_firstUpper + " not resolvable: ");
        String _message = e.getMessage();
        String _plus_1 = (_plus + _message);
        this.error(_plus_1, feature, BXtendDSLValidator.METAMODEL_NOT_RESOLVABLE);
        return null;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    final Resource metamodelRes = _xtrycatchfinallyexpression;
    boolean _isEmpty = metamodelRes.getErrors().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      String cause = metamodelRes.getErrors().get(0).getMessage();
      boolean _contains = cause.contains("SAXParseException");
      if (_contains) {
        cause = cause.replaceFirst("\\A[\\s\\S]*lineNumber: ", "lineNumber: ");
      }
      this.error(((("Loading " + modelDescr) + " failed: ") + cause), feature, BXtendDSLValidator.LOADING_METAMODEL_FAILED);
      return null;
    }
    int _size = metamodelRes.getContents().size();
    boolean _notEquals = (_size != 1);
    if (_notEquals) {
      final String cause_1 = "The metamodel must have a single root element!";
      String _firstUpper = StringExtensions.toFirstUpper(modelDescr);
      String _plus = (_firstUpper + " not applicable: ");
      String _plus_1 = (_plus + cause_1);
      this.error(_plus_1, feature, BXtendDSLValidator.METAMODEL_NOT_APPLICABLE);
      return null;
    }
    EObject _get = metamodelRes.getContents().get(0);
    boolean _not_1 = (!(_get instanceof EPackage));
    if (_not_1) {
      final String cause_2 = "The metamodel root must be an EPackage!";
      String _firstUpper_1 = StringExtensions.toFirstUpper(modelDescr);
      String _plus_2 = (_firstUpper_1 + " not applicable: ");
      String _plus_3 = (_plus_2 + cause_2);
      this.error(_plus_3, feature, BXtendDSLValidator.METAMODEL_NOT_APPLICABLE);
      return null;
    }
    return metamodelRes;
  }
  
  private void checkDuplicatedMappingFeature(final List<? extends MappingFeature> mappingFeatures, final EStructuralFeature feature) {
    final Function1<MappingFeature, String> _function = (MappingFeature it) -> {
      return this._utils.token(it);
    };
    final List<String> featureTokens = ListExtensions.map(mappingFeatures, _function);
    for (int i = 0; (i < mappingFeatures.size()); i++) {
      {
        final MappingFeature mappingFeature = mappingFeatures.get(i);
        final String token = featureTokens.get(i);
        final Function1<MappingFeature, Boolean> _function_1 = (MappingFeature it) -> {
          return Boolean.valueOf((Objects.equal(it.getFeature(), mappingFeature.getFeature()) && (it.isCorr() == mappingFeature.isCorr())));
        };
        int _size = IterableExtensions.size(IterableExtensions.filter(mappingFeatures, _function_1));
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          String _xifexpression = null;
          boolean _isCorr = mappingFeature.isCorr();
          boolean _not = (!_isCorr);
          if (_not) {
            _xifexpression = (("Duplicated mapping parameter: \'" + token) + "\'");
          } else {
            _xifexpression = (("Duplicated mapping parameter: \'{" + token) + " : ...}\'");
          }
          final String message = _xifexpression;
          this.error(message, feature, i, BXtendDSLValidator.DUPLICATED_MAPPING_PARAM);
        }
      }
    }
  }
  
  private void checkDuplicatedMappingClass(final List<ClassMatcher> matchers, final EStructuralFeature feature) {
    for (int i = 0; (i < matchers.size()); i++) {
      {
        final ClassMatcher matcher = matchers.get(i);
        final Function1<ClassMatcher, Boolean> _function = (ClassMatcher it) -> {
          return Boolean.valueOf(Objects.equal(it, matcher));
        };
        int _size = IterableExtensions.size(IterableExtensions.<ClassMatcher>filter(matchers, _function));
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          String _name = matcher.getName();
          String _plus = ("Duplicated mapping parameter: \'" + _name);
          final String message = (_plus + "\'");
          this.error(message, feature, i, BXtendDSLValidator.DUPLICATED_MAPPING_PARAM);
        }
      }
    }
  }
  
  private List<String> outParams(final FeatureMapping mapping) {
    ArrayList<String> outParams = new ArrayList<String>();
    List<String> _outSrcParams = this.outSrcParams(mapping);
    Iterables.<String>addAll(outParams, _outSrcParams);
    List<String> _outTrgParams = this.outTrgParams(mapping);
    Iterables.<String>addAll(outParams, _outTrgParams);
    return outParams;
  }
  
  private List<String> outSrcParams(final FeatureMapping mapping) {
    ArrayList<String> outParams = new ArrayList<String>();
    if ((Objects.equal(mapping.getDirection(), Direction.BWD) || Objects.equal(mapping.getDirection(), Direction.BX))) {
      final Function1<SrcMappingFeature, String> _function = (SrcMappingFeature it) -> {
        return this._utils.token(it);
      };
      List<String> _map = ListExtensions.<SrcMappingFeature, String>map(mapping.getSrcFeatures(), _function);
      Iterables.<String>addAll(outParams, _map);
      final Function1<SrcClassMatcher, String> _function_1 = (SrcClassMatcher it) -> {
        return it.getName();
      };
      Iterable<String> _map_1 = IterableExtensions.<SrcClassMatcher, String>map(Iterables.<SrcClassMatcher>filter(mapping.getSrcClasses(), SrcClassMatcher.class), _function_1);
      Iterables.<String>addAll(outParams, _map_1);
    }
    return outParams;
  }
  
  private List<String> outTrgParams(final FeatureMapping mapping) {
    ArrayList<String> outParams = new ArrayList<String>();
    if ((Objects.equal(mapping.getDirection(), Direction.FWD) || Objects.equal(mapping.getDirection(), Direction.BX))) {
      final Function1<TrgMappingFeature, String> _function = (TrgMappingFeature it) -> {
        return this._utils.token(it);
      };
      List<String> _map = ListExtensions.<TrgMappingFeature, String>map(mapping.getTrgFeatures(), _function);
      Iterables.<String>addAll(outParams, _map);
      final Function1<TrgClassMatcher, String> _function_1 = (TrgClassMatcher it) -> {
        return it.getName();
      };
      Iterable<String> _map_1 = IterableExtensions.<TrgClassMatcher, String>map(Iterables.<TrgClassMatcher>filter(mapping.getTrgClasses(), TrgClassMatcher.class), _function_1);
      Iterables.<String>addAll(outParams, _map_1);
    }
    return outParams;
  }
}
