/*
 * generated by Xtext 2.15.0
 */
package de.ubt.ai1.m2m.bxtenddsl.validation

import com.google.inject.Inject
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSL
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.BXtendDSLPackage
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.ClassMatcher
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Config
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Correspondence
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Direction
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.FeatureMapping
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.MappingFeature
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.Metamodels
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcClassMatcher
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.SrcMappingFeature
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TransformationRule
import de.ubt.ai1.m2m.bxtenddsl.bXtendDSL.TrgClassMatcher
import de.ubt.ai1.m2m.bxtenddsl.utils.MetamodelLoader
import de.ubt.ai1.m2m.bxtenddsl.utils.Utils
import java.io.IOException
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BXtendDSLValidator extends AbstractBXtendDSLValidator {
	public static val METAMODEL_NOT_RESOLVABLE = "metamodelNotResolvable"
	public static val LOADING_METAMODEL_FAILED = "loadingMetamodelFailed"
	public static val METAMODEL_NOT_APPLICABLE = "metamodelNotApplicable"
	public static val FORBIDDEN_OPTION_NAME = "forbiddenOptionName"
	public static val AMBIGUOUS_OPTION_NAME = "ambiguousOptionName"
	public static val FORBIDDEN_RULE_NAME = "forbiddenRuleName"
	public static val AMBIGUOUS_RULE_NAME = "ambiguousRuleName"
	public static val FORBIDDEN_CLASS_MATCHER_NAME = "forbiddenClassMatcherName"
	public static val AMBIGUOUS_CLASS_MATCHER_NAME = "ambiguousClassMatcherName"
	public static val DUPLICATED_MAPPING_PARAM = "duplicatedMappingParam"
	public static val MAPPING_PARAM_ALREADY_SET = "mappingParamAlreadySet"
	public static val UNCHANGEABLE_MAPPING_FEATURE = "unchangeableMappingFeature"
	public static val ATTRIBUTE_CORR_MAPPING_FEATURE = "attributeCorrMappingFeature"
	public static val DUPLICATED_CORR_MAPPING_RULE = "duplicatedCorrMappingRule"
	public static val UNRESOLVABLE_CORR_MAPPING_RULE = "unresolvableCorrMappingRule"
	public static val CORR_MAPPING_RULE_BEFORE_RULE = "corrMappingRuleBeforeRule"
	public static val DUPLICATED_CORR_MAPPING_MATCHER = "duplicatedCorrMappingMatcher"
	public static val FORBIDDEN_CLASS_MAPPING_PARAM = "forbiddenClassMappingParam"
	public static val NO_OUT_MAPPING_PARAM = "noOutMappingParam"
	
	/**
	 * Checks if the sourcemodel uri is resolvable, can be loaded and applied as metamodel.
	 */
	@Check
	def checkSourcemodelUri(Metamodels metamodels) {
		checkMetamodelUri(metamodels, BXtendDSLPackage.Literals.METAMODELS__SOURCEMODEL, metamodels.sourcemodel)
	}
	/**
	 * Checks if the targetmodel uri is resolvable, can be loaded and applied as metamodel.
	 */
	@Check
	def checkTargetmodelUri(Metamodels metamodels) {
		checkMetamodelUri(metamodels, BXtendDSLPackage.Literals.METAMODELS__TARGETMODEL, metamodels.targetmodel)
	}
	
	@Check
	def checkForbiddenOptionName(Config config) {
		for (var i = 0; i < config.options.size(); i++) {
			if (!config.options.get(i).matches("[A-Z][A-Z_\\d]*")) {
				val cause = "'" + config.options.get(i) + "'."
				val details = if (!config.options.get(i).matches("[A-Z_\\d]*")) {
					" Only upper case letters, digits and underscores are allowed."
				} else {
					" The first character must be an upper case letter."
				}
				val feature = BXtendDSLPackage.Literals.CONFIG__OPTIONS
				error("Forbidden option name: " + cause + details, feature, i, FORBIDDEN_OPTION_NAME)
			}
		}
	}
	@Check
	def checkAmbigiuousOptionName(Config config) {
		for (var i = 0; i < config.options.size(); i++) {
			val option = config.options.get(i)
			if (config.options.filter[it == option].size() > 1) {
				val feature = BXtendDSLPackage.Literals.CONFIG__OPTIONS
				error("Ambiguous option name: '" + config.options.get(i) + "'", feature, i, AMBIGUOUS_OPTION_NAME)
			}
		}
	}
	
	@Check
	def checkRuleNameNotForbidden(TransformationRule rule) {
		val feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__NAME
		if (rule.name == "Elem2Elem") {
			val cause = "'Elem2Elem' is the name of the base class for transformation rules!"
			error("Forbidden rule name: " + cause, feature, FORBIDDEN_RULE_NAME)
		} else if (rule.name.endsWith("Impl")) {
			val cause = "Rule names ending with 'Impl' are reserved for rule specialization!"
			error("Forbidden rule name: " + cause, feature, FORBIDDEN_RULE_NAME)
		}
	}
	@Check
	def checkRuleNameUnique(TransformationRule rule) {
		if ((rule.eContainer as BXtendDSL).rules.filter[name == rule.name].size() > 1) {
			val feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__NAME
			val cause = "'" + rule.name + "'"
			error("Ambiguous rule name: " + cause, feature, AMBIGUOUS_RULE_NAME)
		}
	}
	
	@Check
	def checkClassMatcherNameNotForbidden(ClassMatcher matcher) {
		if (matcher.name.startsWith("_")) {
			val feature = BXtendDSLPackage.Literals.CLASS_MATCHER__NAME
			val cause = "Class matcher names may not start with an underscore!"
			error("Forbidden class matcher name: " + cause, feature, FORBIDDEN_CLASS_MATCHER_NAME)
		}
	}
	@Check
	def checkClassMatcherNameUnique(ClassMatcher matcher) {
		var allMatcher = new ArrayList<ClassMatcher>()
		allMatcher += (matcher.eContainer as TransformationRule).srcMatcher
		allMatcher += (matcher.eContainer as TransformationRule).trgMatcher
		
		if (allMatcher.filter[name == matcher.name].size() > 1) {
			val feature = BXtendDSLPackage.Literals.CLASS_MATCHER__NAME
			val cause = "'" + matcher.name + "'"
			error("Ambiguous class matcher name: " + cause, feature, AMBIGUOUS_CLASS_MATCHER_NAME)
		}
	}
	
	@Check
	def checkDuplicatedMappingParam(FeatureMapping mapping) {
		checkDuplicatedMappingFeature(mapping.srcFeatures, BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES)
		checkDuplicatedMappingFeature(mapping.trgFeatures, BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES)
		checkDuplicatedMappingClass(mapping.srcClasses, BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES)
		checkDuplicatedMappingClass(mapping.trgClasses, BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES)
	}
	
	@Check
	def checkUnchangeableMappingFeature(FeatureMapping mapping) {
		if (mapping.direction == Direction.BWD || mapping.direction == Direction.BX) {
			for (var i = 0; i < mapping.srcFeatures.size(); i++) {
				if (!mapping.srcFeatures.get(i).feature.changeable) {
					val token = mapping.srcFeatures.get(i).token
					val cause = "'" + token + "'. It must not be used as out parameter of a mapping."
					val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES
					error("Unchangeable mapping feature: " + cause, feature, i, UNCHANGEABLE_MAPPING_FEATURE)
				}
			}
		}
		if (mapping.direction == Direction.FWD || mapping.direction == Direction.BX) {
			for (var i = 0; i < mapping.trgFeatures.size(); i++) {
				if (!mapping.trgFeatures.get(i).feature.changeable) {
					val token = mapping.trgFeatures.get(i).token
					val cause = "'" + token + "'. It must not be used as out parameter of a mapping."
					val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES
					error("Unchangeable mapping feature: " + cause, feature, i, UNCHANGEABLE_MAPPING_FEATURE)
				}
			}
		}
	}
	
	@Check
	def checkMappingParamAlreadySet(FeatureMapping mapping) {
		var setBeforeParams = new HashSet<String>()
		for (mappingBefore : (mapping.eContainer as TransformationRule).mappings.takeWhile[it != mapping]) {
			setBeforeParams += outParams(mappingBefore)
		}
		val outParams = outParams(mapping)
		
		for (var i = 0; i < mapping.srcFeatures.size(); i++) {
			val token = mapping.srcFeatures.get(i).token
			if (outParams.contains(token) && setBeforeParams.contains(token)) {
				val cause = "'" + token + "'. This assignment overwrites the previous assignment."
				val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_FEATURES
				warning("Mapping parameter already set: " + cause, feature, i, MAPPING_PARAM_ALREADY_SET)
			}
		}
		for (var i = 0; i < mapping.trgFeatures.size(); i++) {
			val token = mapping.trgFeatures.get(i).token
			if (outParams.contains(token) && setBeforeParams.contains(token)) {
				val cause = "'" + token + "'. This assignment overwrites the previous assignment."
				val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_FEATURES
				warning("Mapping parameter already set: " + cause, feature, i, MAPPING_PARAM_ALREADY_SET)
			}
		}
		
		for (var i = 0; i < mapping.srcClasses.size(); i++) {
			if (mapping.srcClasses.get(i) instanceof SrcClassMatcher) {
				val matcher = mapping.srcClasses.get(i).name
				if (outParams.contains(matcher) && setBeforeParams.contains(matcher)) {
					val cause = "'" + matcher + "'. This assignment overwrites the previous assignment."
					val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES
					warning("Mapping parameter already set: " + cause, feature, i, MAPPING_PARAM_ALREADY_SET)
				}
			}
		}
		for (var i = 0; i < mapping.trgClasses.size(); i++) {
			if (mapping.trgClasses.get(i) instanceof TrgClassMatcher) {
				val matcher = mapping.trgClasses.get(i).name
				if (outParams.contains(matcher) && setBeforeParams.contains(matcher)) {
					val cause = "'" + matcher + "'. This assignment overwrites the previous assignment."
					val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES
					warning("Mapping parameter already set: " + cause, feature, i, MAPPING_PARAM_ALREADY_SET)
				}
			}
		}
	}
	
	@Check
	def checkAttributeCorrMappingFeature(MappingFeature mappingFeature) {
		if (mappingFeature.corr && mappingFeature.feature instanceof EAttribute) {
			val cause = "'{" + mappingFeature.token + " : ...}'. Correspondences can only be resolved for references!"
			val feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__FEATURE
			error("Attribute corr mapping feature: " + cause, feature, ATTRIBUTE_CORR_MAPPING_FEATURE)
		}
	}
	
	@Check
	def checkDuplicatedCorrMappingRule(MappingFeature mappingFeature) {
		for (var i = 0; i < mappingFeature.corrs.size(); i++) {
			val rule = mappingFeature.corrs.get(i).rule
			if (mappingFeature.corrs.filter[it.rule == rule].size() > 1) {
				val message = "Duplicated corr mapping rule: '" + rule.name + "'"
				val feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS
				error(message, feature, i, DUPLICATED_CORR_MAPPING_RULE)
			}
		}
	}
	
	@Check
	def checkUnresolvableCorrMappingRule(MappingFeature mappingFeature) {
		if (!(mappingFeature.feature.EType instanceof EClass)) {
			return // handled by checkAttributeCorrMappingFeature
		}
		val featureEClass = mappingFeature.feature.EType as EClass
		
		for (var i = 0; i < mappingFeature.corrs.size(); i++) {
			val rule = mappingFeature.corrs.get(i).rule
			val matchers = if (mappingFeature instanceof SrcMappingFeature) rule.srcMatcher else rule.trgMatcher
			if (!matchers.exists[clazz.isSuperTypeOf(featureEClass) || featureEClass.isSuperTypeOf(clazz)]) {
				val message = "Unresolvable corr mapping rule: "
				val matcher = if (mappingFeature instanceof SrcMappingFeature) "src matcher" else "trg matcher"
				val hint = '''No «matcher» of '«rule.name»' fits to the type of '«mappingFeature.token»'.'''
				val feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS
				error(message + hint, feature, i, UNRESOLVABLE_CORR_MAPPING_RULE)
			}
		}
	}
	
	@Check
	def checkCorrMappingRuleBeforeRule(MappingFeature mappingFeature) {
		val rules = EcoreUtil2.getContainerOfType(mappingFeature, BXtendDSL).rules
		val featureRule = EcoreUtil2.getContainerOfType(mappingFeature, TransformationRule)
		for (var i = 0; i < mappingFeature.corrs.size(); i++) {
			val corrRule = mappingFeature.corrs.get(i).rule
			if (rules.indexOf(featureRule) < rules.indexOf(corrRule)) {
				val hint = ''''«corrRule.name»' can't be resolved, because it is executed after '«featureRule.name»'.'''
				val feature = BXtendDSLPackage.Literals.MAPPING_FEATURE__CORRS
				error("Corr mapping rule before rule: " + hint, feature, i, CORR_MAPPING_RULE_BEFORE_RULE)
			}
		}
	}
	
	@Check
	def checkDuplicatedCorrMappingMatcher(Correspondence corr) {
		for (var i = 0; i < corr.matchers.size(); i++) {
			val matcher = corr.matchers.get(i)
			if (corr.matchers.filter[it == matcher].size() > 1) {
				val message = "Duplicated corr mapping matcher: '" + matcher.name + "'"
				val feature = BXtendDSLPackage.Literals.CORRESPONDENCE__MATCHERS
				error(message, feature, i, DUPLICATED_CORR_MAPPING_MATCHER)
			}
		}
	}
	
	@Check
	def checkForbiddenClassMappingParam(FeatureMapping featureMapping) {
		for (var i = 0; i < featureMapping.srcClasses.size(); i++) {
			val matcher = featureMapping.srcClasses.get(i)
			if (!matcher.modifier.group && matcher instanceof SrcClassMatcher) {
				val cause = "'" + matcher.name + "'. Features of not grouped src class parameters must be accessed"
						+ " directly on this rule side."
				val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__SRC_CLASSES
				error("Forbidden class mapping parameter: " + cause, feature, i, FORBIDDEN_CLASS_MAPPING_PARAM)
			}
		}
		for (var i = 0; i < featureMapping.trgClasses.size(); i++) {
			val matcher = featureMapping.trgClasses.get(i)
			if (!matcher.modifier.group && matcher instanceof TrgClassMatcher) {
				val cause = "'" + matcher.name + "'. Features of not grouped trg class parameters must be accessed"
						+ " directly on this rule side."
				val feature = BXtendDSLPackage.Literals.FEATURE_MAPPING__TRG_CLASSES
				error("Forbidden class mapping parameter: " + cause, feature, i, FORBIDDEN_CLASS_MAPPING_PARAM)
			}
		}
	}
	
	@Check
	def checkNoOutMappingParam(TransformationRule rule) {
		for (var i = 0; i < rule.mappings.size(); i++) {
			val mapping = rule.mappings.get(i)
			val direction = mapping.direction
			if ((direction == Direction.BWD || direction == Direction.BX) && outSrcParams(mapping).empty) {
				val cause = "Direction <-- is specified, but the lhs contains no out parameter!"
				val feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__MAPPINGS
				error("No out mapping parameter: " + cause, feature, i, NO_OUT_MAPPING_PARAM)
			}
			if ((direction == Direction.FWD || direction == Direction.BX) && outTrgParams(mapping).empty) {
				val cause = "Direction --> is specified, but the rhs contains no out parameter!"
				val feature = BXtendDSLPackage.Literals.TRANSFORMATION_RULE__MAPPINGS
				error("No out mapping parameter: " + cause, feature, i, NO_OUT_MAPPING_PARAM)
			}
		}
	}
	
	@Inject extension Utils
	
	def private checkMetamodelUri(Metamodels container, EAttribute feature, String metamodel) {
		val metamodelRes = loadMetamodel(container, feature, metamodel, false)
		if (metamodelRes === null) {
			return
		}
		
		val Set<String> referencedMetamodels = newHashSet()
		for (class : metamodelRes.allContents.filter(typeof(EClass)).toIterable()) {
			val referencedClasses = newArrayList()
			referencedClasses += class.EAllSuperTypes.filter(typeof(EClass))
			referencedClasses += class.EAllStructuralFeatures.map[EType].filter(typeof(EClass))
			if (referencedClasses.exists[!(EcoreUtil2.getRootContainer(it) instanceof EPackage)]) {
				val eclass = referencedClasses.findFirst[!(EcoreUtil2.getRootContainer(it) instanceof EPackage)]
				error('''The root container of EClass '«eclass»' is no EPackage!''', feature)
			}
			
			referencedMetamodels += referencedClasses
				.map[EcoreUtil2.getRootContainer(it)]
				.filter(typeof(EPackage))
				.map[nsURI]
				.filter[it != metamodel]
		}
		
		for (referencedMetamodel : referencedMetamodels) {
			loadMetamodel(container, feature, metamodel, true)
		}
	}
	
	def private Resource loadMetamodel(Metamodels container, EAttribute feature, String metamodel, boolean referenced) {
		if (metamodel === null) {
			return null
		}
		
		val modelDescr = if (referenced) {
			"referenced metamodel '" + metamodel +"'"
		} else {
			"metamodel"
		}
		
		val metamodelRes = try {
			MetamodelLoader.load(metamodel, container.eResource.resourceSet)
		} catch (IOException e) {
			error(modelDescr.toFirstUpper() + " not resolvable: " + e.message, feature, METAMODEL_NOT_RESOLVABLE)
			return null
		}
		
		if (!metamodelRes.errors.isEmpty) {
			var cause = metamodelRes.errors.get(0).message
			if (cause.contains("SAXParseException")) {
				cause = cause.replaceFirst("\\A[\\s\\S]*lineNumber: ", "lineNumber: ")
			}
			error("Loading " + modelDescr + " failed: " + cause, feature, LOADING_METAMODEL_FAILED)
			return null
		}
		
		// loading fails for all models with size != 1, extra safety for runtime models
		if (metamodelRes.contents.size() != 1) {
			val cause = "The metamodel must have a single root element!"
			error(modelDescr.toFirstUpper() + " not applicable: " + cause, feature, METAMODEL_NOT_APPLICABLE)
			return null
		}
		if (!(metamodelRes.contents.get(0) instanceof EPackage)) {
			val cause = "The metamodel root must be an EPackage!"
			error(modelDescr.toFirstUpper() + " not applicable: " + cause, feature, METAMODEL_NOT_APPLICABLE)
			return null
		}
		
		return metamodelRes
	}
	
	def private checkDuplicatedMappingFeature(List<? extends MappingFeature> mappingFeatures,
			EStructuralFeature feature) {
		val featureTokens = mappingFeatures.map[token]
		
		for (var i = 0; i < mappingFeatures.size(); i++) {
			val mappingFeature = mappingFeatures.get(i)
			val token = featureTokens.get(i)
			
			if (mappingFeatures.filter[it.feature == mappingFeature.feature
					&& it.corr == mappingFeature.corr].size() > 1) {
				val message = if (!mappingFeature.corr) {
					"Duplicated mapping parameter: '" + token + "'"
				} else {
					"Duplicated mapping parameter: '{" + token + " : ...}'"
				}
				error(message, feature, i, DUPLICATED_MAPPING_PARAM)
			}
		}
	}
	def private checkDuplicatedMappingClass(List<ClassMatcher> matchers, EStructuralFeature feature) {
		for (var i = 0; i < matchers.size(); i++) {
			val matcher = matchers.get(i)
			if (matchers.filter[it == matcher].size() > 1) {
				val message = "Duplicated mapping parameter: '" + matcher.name + "'"
				error(message, feature, i, DUPLICATED_MAPPING_PARAM)
			}
		}
	}
	
	def private List<String> outParams(FeatureMapping mapping) {
		var outParams = new ArrayList<String>()
		outParams += outSrcParams(mapping)
		outParams += outTrgParams(mapping)
		return outParams
	}
	def private List<String> outSrcParams(FeatureMapping mapping) {
		var outParams = new ArrayList<String>()
		if (mapping.direction == Direction.BWD || mapping.direction == Direction.BX) {
			outParams += mapping.srcFeatures.map[token]
			outParams += mapping.srcClasses.filter(typeof(SrcClassMatcher)).map[name]
		}
		return outParams
	}
	def private List<String> outTrgParams(FeatureMapping mapping) {
		var outParams = new ArrayList<String>()
		if (mapping.direction == Direction.FWD || mapping.direction == Direction.BX) {
			outParams += mapping.trgFeatures.map[token]
			outParams += mapping.trgClasses.filter(typeof(TrgClassMatcher)).map[name]
		}
		return outParams
	}
}
